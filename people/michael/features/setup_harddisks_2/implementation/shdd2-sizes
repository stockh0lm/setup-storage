#!/usr/bin/perl -w

use strict;

package FAI;

%FAI::current_config = ();

foreach my $disk ( @FAI::disks )
{
  if( ! ( $disk =~ m{^/} ) )
  {
    $disk = "/dev/" . $disk;
  }
  $FAI::current_config{ $disk } = {
    "partitions" => {}
  };
  
  my @parted_print = split( "\n", `/sbin/parted -s $disk unit TB print` );
  my $parted_fs_start = 0;
  my $parted_fs_end = 0;

  foreach my $line ( @parted_print )
  {
    if( $line =~ /^Disk geometry/ )
    {
      next;
    }
    elsif( $line =~ /^Disk label type: (.*)$/ )
    {
      $FAI::current_config{ $disk } = {
        "disklabel" => $1
      };
      next;
    }
    elsif( $line =~ /^Number/ )
    {
      $parted_fs_start = 0;
      $parted_fs_end = 0;
      my @chars = split( "", $line );
      foreach my $char ( @chars )
      {
        $parted_fs_end++;
        if( $char eq "F" )
        {
          $parted_fs_start = $parted_fs_end;
        }
        elsif( $char eq "m" && $parted_fs_start > 0 )
        {
          last;
        }
      }
      $parted_fs_start--;
      $parted_fs_end -= $parted_fs_start;
    }
    else
    {
      $line =~ /^(\d+)/;
      my $id = $1;
      $line =~ /^.{$parted_fs_start}(.{$parted_fs_end})/;
      my $fs = $1;
      $FAI::current_config{ $disk }{ "partitions" }{ $id } = {
        "filesystem" => $fs
      };
    }
  }


  @parted_print = split( "\n", `/sbin/parted -s $disk unit B print` );
  {
    foreach my $line ( @parted_print )
    {
      if( $line =~ /^(\d+)*\s+(\d+)B\s+(\d+)B\s+(\d+)B/i )
      {

        $FAI::current_config{ $disk }{ "partitions" }{ $1 } = {
          "begin_byte" => $2,
          "end_byte" => $3,
          "count_byte" => $4
        };
      }

      if( $line =~ /^Disk geometry for.*(\d+)B - (\d+)B/i )
      {
        $FAI::current_config{ $disk } = {
          "begin_byte" => $1,
          "end_byte" => $2
        }        
      }

    #  if( $line =~ /^Disk label type:\s*(\w*)\s*/i )
    #  {
    #    
    #    printf $1;
    #  }
    }
  }



  @parted_print = split( "\n", `/sbin/parted -s $disk unit chs print` );
  {
    foreach my $line ( @parted_print )
    {

      if( $line =~ /^(\d+)\s+(\d+),(\d+),(\d+)\s+(\d+),(\d+),(\d+)/i )
      {
        $FAI::current_config{ $disk }{ "partitions" }{ $1 } = {
          "begin_cylinder" => $2,
          "begin_head" => $3,
          "begin_sector" => $4,
          "end_cylinder" => $5,
          "end_head" => $6,
          "end_sector" => $7
        };
      
      }

      if( $line =~ /^Disk geometry for.*(\d+),(\d+),(\d+) - (\d+),(\d+),(\d+)/i )
      {
        
        $FAI::current_config{ $disk } = {
          "begin_cylinder" => $1,
          "begin_head" => $2,
          "begin_sector" => $3,
          "end_cylinder" => $4,
          "end_head" => $5,
          "end_sector" => $6
        };
      }
    }
  }
}


foreach my $config ( keys %FAI::configs )
{
  if( $config eq "RAID" || $config =~ /^VG_/ )
  {
    next;
  }
  elsif( $config =~ /^PHY_(.*)$/ )
  {
    my $extended = -1;
    foreach my $part_id ( sort keys %{ $FAI::configs{ $config }{ "partitions" } } )
    {
      if( $FAI::configs{ $config }{ "partitions" }{ $part_id }{ "size" }{ "extended" } == 1 )
      {
      }
      elsif( $FAI::configs{ $config }{ "partitions" }{ $part_id }{ "size" }{ "preserve" } == 0 )
      {
        my $part_size = $FAI::configs{ $config }{ "partitions" }{ $part_id }{
        "size" }{ "range" };
      }
      # compute size of extended later on
    }
  }
  else
  {
    warn "Internal error (invalid config entry $config).\n";
  }
}

1;

