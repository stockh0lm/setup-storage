#!/usr/bin/perl -w

use strict;
use File::Temp;

package FAI;

$FAI::error_codes = [
  {
    error        => "parted_1",
    message      => "Parted produced error. Couldn't remove Partition",
    stderr_regex =>
      ".*Error: Could not stat device rm - No such file or directory.*",
    stdout_regex => "",
    program      => "parted",
    response     => "die",
  },
  {
    error        => "parted_2",
    message      => "Parted produced error. Could not read disk label.",
    stderr_regex => ".*Error: Unable to open .* - unrecognised disk label.*",
    stdout_regex => "",
    program      => "parted",
    response     => "die",
  },
  {
    error        => "parted_3",
    message      => "Parted produced error. Could not open disk",
    stderr_regex =>
      ".*Error: Could not stat device .* - No such file or directory.*",
    stdout_regex => "",
    program      => "parted",
    response     => "die"
  },
  {
    error        => "port_1",
    message      => "test_error",
    stderr_regex => ".*Error: .* Port test not found.*",
    stdout_regex => "",
    program      => "port",
    response     => "die"
  },
];

sub get_error_message
{
  my ($error) = @_;
  my @treffer = grep { $_->{error} eq "$error" } @$FAI::error_codes;
  foreach my $m (@treffer)    #returns the first found error message.
  {
    return "$m->{'message'}";
  }
}

sub get_error
{
  my ( $error, $field ) = @_;
  my @treffer = grep { $_->{error} eq "$error" } @$FAI::error_codes;
  foreach my $m (@treffer)    #returns the first found error message.
  {
    return "$m->{$field}";
  }
}

sub execute_command_std       #execute command with standard error handling
{
  my ( $command, $stdout_ref, $stderr_ref ) = @_;
  my $err = &execute_command( $command, $stdout_ref, $stderr_ref );
  my $response = &get_error( $err, "response" );
  my $message  = &get_error( $err, "message" );

  if ( $response eq "die" )
  {
    die $message;
  }

  if ( $response eq "warn" )
  {
    warn $message;
  }

  return $err;
}

sub execute_command
{
  my ( $command, $stdout_ref, $stderr_ref ) = @_;

  my @stderr      = ();
  my @stdout      = ();
  my $stderr_line = "";
  my $stdout_line = "";
  my $run         = $ENV{"NO_DRY_RUN"};

  ( my $stderr_fh, my $stderr_filename ) = File::Temp::tempfile();
  ( my $stdout_fh, my $stdout_filename ) = File::Temp::tempfile();

  if ( $run == 1 )
  {
    `$command 1> $stdout_filename 2> $stderr_filename`;
  }
  else
  {
    printf
"would run command $command, to run in NO_DRY_MODE, please set environment variable NO_DRY_RUN to 1";
  }

  @stderr = <$stderr_fh>;
  @stdout = <$stdout_fh>;

  close($stderr_fh);
  close($stdout_fh);

  if ( scalar(@stderr) > 0 )
  {
    $stderr_line = $stderr[0];
  }

  if ( scalar(@stdout) > 0 )
  {
    $stdout_line = $stdout[0];
  }

  if ( 'ARRAY' eq ref($stdout_ref) )
  {
    @$stdout_ref = @stdout;
  }

  if ( 'ARRAY' eq ref($stderr_ref) )
  {
    @$stderr_ref = @stderr;
  }

  foreach my $err (@$FAI::error_codes)
  {
    if (
      (
        $err->{'stdout_regex'} eq "" || $stdout_line =~ /$err->{'stdout_regex'}/
      )
      && ( $err->{'stderr_regex'} eq ""
        || $stderr_line =~ /$err->{'stderr_regex'}/ )
      && ( $err->{'program'} eq "" || $command =~ /.*$err->{'program'}.*/ )
      )
    {

      return $err->{'error'};
    }
  }

}

1;

