#!/usr/bin/perl -w

#*********************************************************************
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# A copy of the GNU General Public License is available as
# `/usr/share/common-licences/GPL' in the Debian GNU/Linux distribution
# or on the World Wide Web at http://www.gnu.org/copyleft/gpl.html. You
# can also obtain it by writing to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#*********************************************************************

use strict;

################################################################################
#
# @file shdd2-exec
#
# @brief functions to execute system commands
#
# $Id$
#
# @author Christian Kern, Michael Tautschnig
# @date Sun Jul 23 16:09:36 CEST 2006
#
################################################################################

use File::Temp;

package FAI;

################################################################################
#
# @brief hash, defined: errors, descriptions, actions on error
#
# @scalar error error
# @scalar message our errormessage
# @scalar stderr_regex regex to recognize the error message on stderr output of the bash
# @scalar stdout_regex regex to recognize the error message on stdout output of the bash
# @scalar program the program this error message can come from
# @scalar response default action on this error.
#
################################################################################
$FAI::error_codes = [
  {
    error        => "parted_1",
    message      => "Parted produced error. Couldn't remove Partition",
    stderr_regex =>
      ".*Error: Could not stat device rm - No such file or directory.*",
    stdout_regex => "",
    program      => "parted",
    response     => "die",
  },
  {
    error        => "parted_2",
    message      => "Parted produced error. Could not read disk label.",
    stderr_regex => ".*Error: Unable to open .* - unrecognised disk label.*",
    stdout_regex => "",
    program      => "parted",
    response     => "die",
  },
  {
    error        => "parted_3",
    message      => "Parted produced error. Could not open disk",
    stderr_regex =>
      ".*Error: Could not stat device .* - No such file or directory.*",
    stdout_regex => "",
    program      => "parted",
    response     => "die"
  },
  {
    error        => "port_1",
    message      => "test_error",
    stderr_regex => ".*Error: .* Port test not found.*",
    stdout_regex => "",
    program      => "port",
    response     => "die"
  },
];

################################################################################
#
# @brief returns the error message associated with an error
#
# @param error identifier of an error
#
# @return our interpretation of the error as string
#
################################################################################
sub get_error_message
{
  my ($error) = @_;
  my @treffer = grep { $_->{error} eq "$error" } @$FAI::error_codes;
  foreach my $m (@treffer)    #returns the first found error message.
  {
    return "$m->{'message'}";
  }
}

################################################################################
#
# @brief gets any part of the error struct associated with an error
#
# @param error identifier of an error
# @param field field of the error struct as string, example: "stderr_regex"
#
# @return the associated value
#
################################################################################
sub get_error
{
  my ( $error, $field ) = @_;
  my @treffer = grep { $_->{error} eq "$error" } @$FAI::error_codes;
  foreach my $m (@treffer)    #returns the first found error message.
  {
    return "$m->{$field}";
  }
}
################################################################################
#
# @brief execute a /bin/bash command, given as string. also catch stderr and
# stdout, to be passed to the caller function, and also used for error
# recognition. This execute function does execute the in the error struct
# defined action, when an error occurs.
#
# @param command bash command to be executed as string
# @reference stdout_ref reference to a list, that should contain the standard
# output of the bash command
#
# @reference stderr_ref reference to a list, that should contain the standard
# errer output of the bash command
#
# @return the identifier of the error
#
################################################################################
sub execute_command_std    #execute command with standard error handling
{
  my ( $command, $stdout_ref, $stderr_ref ) = @_;
  my $err = &execute_command( $command, $stdout_ref, $stderr_ref );
  unless ( $err eq "" )
  {
    my $response = &get_error( $err, "response" );
    my $message  = &get_error( $err, "message" );

    if ( $response eq "die" )
    {
      die $message;
    }

    if ( $response eq "warn" )
    {
      warn $message;
    }

    return $err;
  }
  return "";
}

################################################################################
#
# @brief execute a /bin/bash command, given as string. also catch stderr and
# stdout, to be passed to the caller function, and also used for error
# recognition. This caller function must handle the error.
#
# @param command bash command to be executed as string
# @reference stdout_ref reference to a list, that should contain the standard
# output of the bash command
#
# @reference stderr_ref reference to a list, that should contain the standard
# errer output of the bash command
#
# @return the identifier of the error
#
################################################################################
sub execute_command
{
  my ( $command, $stdout_ref, $stderr_ref ) = @_;

  my @stderr      = ();
  my @stdout      = ();
  my $stderr_line = "";
  my $stdout_line = "";
  my $run         = 0;
  if ( defined( $ENV{"NO_DRY_RUN"} ) && !( $ENV{"NO_DRY_RUN"} =~ /^\s*$/ ) )
  {
    $run = 1;
  }

  #make tempfile, get perl filehandle and filename of the file
  ( my $stderr_fh, my $stderr_filename ) = File::Temp::tempfile();
  ( my $stdout_fh, my $stdout_filename ) = File::Temp::tempfile();

  # do only execute the given command, when in no_dry_mode
  if ( $run == 1 )
  {

    # execute the bash command, write stderr and stdout into the testfiles
    `$command 1> $stdout_filename 2> $stderr_filename`;
  }
  else
  {
    printf
"would run command $command, to run in NO_DRY_MODE, please set environment variable NO_DRY_RUN to 1 \n";
  }

  # read the tempfile into lists, each element of the list one line
  @stderr = <$stderr_fh>;
  @stdout = <$stdout_fh>;

  #when closing the files, the tempfiles are removed too
  close($stderr_fh);
  close($stdout_fh);

  #if the stderr contains information, get the first line for error recognition
  if ( scalar(@stderr) > 0 )
  {
    $stderr_line = $stderr[0];
  }

  #see last comment
  if ( scalar(@stdout) > 0 )
  {
    $stdout_line = $stdout[0];
  }

  #if an array is passed to the function, it is filled with the stdout
  if ( 'ARRAY' eq ref($stdout_ref) )
  {
    @$stdout_ref = @stdout;
  }

  #see above
  if ( 'ARRAY' eq ref($stderr_ref) )
  {
    @$stderr_ref = @stderr;
  }

  #get the error, eventually happened
  foreach my $err (@$FAI::error_codes)
  {
    if (
      (
        $err->{'stdout_regex'} eq "" || $stdout_line =~ /$err->{'stdout_regex'}/
      )
      && ( $err->{'stderr_regex'} eq ""
        || $stderr_line =~ /$err->{'stderr_regex'}/ )
      && ( $err->{'program'} eq "" || $command =~ /.*$err->{'program'}.*/ )
      )
    {

      return $err->{'error'};
    }
  }

}

1;

