#!/usr/bin/perl -w

#*********************************************************************
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# A copy of the GNU General Public License is available as
# `/usr/share/common-licences/GPL' in the Debian GNU/Linux distribution
# or on the World Wide Web at http://www.gnu.org/copyleft/gpl.html. You
# can also obtain it by writing to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#*********************************************************************

use strict;

# treat all warnings about uninitialised values as errors
use warnings FATAL => qw(uninitialized);

################################################################################
#
# @file shdd2
#
# @brief The main function of setup harddisks 2 - the tool to configure the
# partitioning from within FAI.
#
# This is an implementation from scratch to properly support LVM and RAID. The
# input format is documented in @ref shdd2-parser
#
# $Id$
#
# @author Christian Kern, Michael Tautschnig
# @date Sun Jul 23 16:09:36 CEST 2006
#
################################################################################

################################################################################
# TODO list
# - parted, libparse-recdescent-perl must get installed in nfsroot (add Depends:
#   to fai-nfsroot package)
#
# - closes #380629, #330915, #277045, #356862, #416633
# - no-bug: #364763
#
# - auto mode (something like auto:server, auto:desktop?)
# - man page
#
# - resize should imply resizing the filesystem as well (unless this is done by
#   parted already, needs to be checked)
# - LVMs definitely require resizing the filesystem
# - more error messages must be caught by shdd2-exec
# - how to detect old-style config files? migration strategies?
# - implement disklabels other than msdos and gpt
# - the RAID commands are surely incomplete and lack any management of
#   unanticipated situations
# - try to get libparted-swig-perl and use that one instead of the manual
#   parsing
################################################################################

package FAI;

# command line parameter handling
use Getopt::Std;

# the variables for getopt
our ( $opt_X, $opt_f );

# parse the command line
&getopts('Xf:') || die <<EOF;
USAGE: [-X]                     no test, your harddisks will be formated
                                default: only test, no real formating
       [-f<config-filename>]    default: parse classes
EOF

# $disklist must be provided by the environment
defined( $ENV{disklist} ) or die "Environment variable disklist is not set";

################################################################################
#
# @brief Really write any changes to disk
#
################################################################################
$FAI::no_dry_run = 0;
($opt_X) and $FAI::no_dry_run = 1;
($opt_X) or warn "shdd2 is running in test-only mode!\n";

# include all subparts
require "shdd2-init";
require "shdd2-lib";
require "shdd2-volumes";
require "shdd2-parser";
require "shdd2-sizes";
require "shdd2-commands";
require "shdd2-fstab";
require "shdd2-exec";

# the config source file
my $config_file = undef;

# use the config file, if given
if ($opt_f) {
  open( $config_file, $opt_f ) or die "Failed to open config file $opt_f\n";
}

# see which class file to use
else {
  foreach my $classfile ( reverse split( /\s+/, $ENV{"classes"} ) ) {
    next unless ( -r "$ENV{'FAI'}/disk_config/$classfile" );
    open( $config_file, "$ENV{'FAI'}/disk_config/$classfile" );
    last;
  }
}

# if we could not find any matching class file, bail out
defined($config_file) or die "No matching disk_config found\n";

# start the parsing - thereby $FAI::configs is filled
&FAI::run_parser($config_file);

# read the sizes and partition tables of all disks listed in $FAI::disks
&FAI::get_current_disks;

# see whether there are any existing LVMs
# load the dm-mod module first, otherwise the LVM tools won't work
`modprobe dm-mod`;
&FAI::get_current_lvm;

# see whether there are any existing RAID devices
# load the md-mod module first, otherwise there is nothing that can be detected
`modprobe md-mod`;
&FAI::get_current_raid;

# for debugging purposes to print the hash structures
use Data::Dumper;

# debugging only: print the current contents of $FAI::current_config
if ($FAI::debug) {
  print "Current disk layout\n";

  # make sure perl doesn't warn about it being used only once
  our %current_config;
  print Dumper \%current_config;

  print "Current LVM layout\n";

  # make sure perl doesn't warn about it being used only once
  our %current_lvm_config;
  print Dumper \%current_lvm_config;

  print "Current RAID layout\n";

  # make sure perl doesn't warn about it being used only once
  our %current_raid_config;
  print Dumper \%current_raid_config;
}

# compute the new LVM and partition sizes; do the partition sizes first to have
# them available for the the volume group size estimation
&FAI::compute_partition_sizes;
&FAI::compute_lv_sizes;

# debugging only: print the current contents of $FAI::configs
if ($FAI::debug) {
  print "Desired disk layout\n";
  print Dumper \%FAI::configs;
}

# generate the command script
&FAI::build_disk_commands;
&FAI::build_raid_commands;
&FAI::build_lvm_commands;

# run all commands
# debugging only: print the command script
($FAI::debug) and print "$_\n" foreach (@FAI::commands);

# run the command (if $FAI::no_dry_run is set)
&FAI::execute_command_std($_) foreach (@FAI::commands);

# generate the proposed fstab contents
my @fstab = &FAI::generate_fstab( \%FAI::configs );

# debugging only; print fstab
($FAI::debug) and print "$_\n" foreach (@fstab);

# write the proposed contents of fstab to $LOGDIR/fstab, if $FAI::no_dry_run is set
if ($FAI::no_dry_run) {
  # write fstab to $LOGDIR/fstab
  open( FSTAB, ">$ENV{LOGDIR}/fstab" )
    or die "Failed to open $ENV{LOGDIR}/fstab for writing\n";
  print FSTAB "$_\n" foreach (@fstab);
  close FSTAB;
}

# write variables to $LOGDIR/disk_var.sh
# debugging
($FAI::debug) and print "$_=$FAI::disk_var{$_}\n"
  foreach ( keys %FAI::disk_var );

# do it, if $FAI::no_dry_run is set
if ($FAI::no_dry_run)
{
  open( DISK_VAR, ">$ENV{LOGDIR}/disk_var.sh" )
    or die "Unable to write to file $ENV{LOGDIR}/disk_var.sh\n";
  print DISK_VAR "$_=$FAI::disk_var{$_}\n" foreach ( keys %FAI::disk_var );
  close DISK_VAR;
}

