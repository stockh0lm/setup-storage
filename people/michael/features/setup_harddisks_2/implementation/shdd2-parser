#!/usr/bin/perl -w

#*********************************************************************
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# A copy of the GNU General Public License is available as
# `/usr/share/common-licences/GPL' in the Debian GNU/Linux distribution
# or on the World Wide Web at http://www.gnu.org/copyleft/gpl.html. You
# can also obtain it by writing to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#*********************************************************************

use strict;

################################################################################
#
# @file shdd2-parser
#
# @brief A parser for the disk_config files within FAI, based on the EBNF
# listed below. The implementation makes use of the RecDescent package.
#
# file ::= <lines> EOF
#
# lines ::= EOL
#           /* empty lines or whitespace only */
#           | <comment> EOL
#           | <config> EOL
#
# comment ::= #.*
#
# config ::= disk_config lvm
#            | disk_config raid
#            | disk_config end
#            | disk_config disk[[:digit:]]+( <option>)*
#            | disk_config [^[:space:]]+( <option>)*
#            /* fully qualified device-path or short form, like hda, whereby full
#             * path is assumed to be /dev/hda */
#            | <volume>
#
# option ::= /* empty */
#            | preserve:[[:digit:]]+(,[[:digit:]]+)*
#            /* preserve partitions */
#            | resize:[[:digit:]]+(,[[:digit:]]+)*
#            /* attempt to resize partitions */
#            | disklabel:(msdos|gpt)
#            /* write a disklabel - default is msdos */
#            | bootable:[[:digit:]]+
#            /* mark a partition bootable, default is / */
#            | virtual
#            /* do not assume the disk to be a physical device, use with xen */
#            | fstabkey:(device|label|uuid)
#            /* when creating the fstab, the key used for defining the device
#            may be the device (/dev/xxx), a label given using -L, or the uuid
#            */
#
# volume ::= <type> <mountpoint> <size> <filesystem> <mount_options> <fs_options>
#            | vg <name> <size>
#            /* lvm vg */
#
# type ::= primary
#          /* for physical disks only */
#          | logical
#          /* for physical disks only */
#          | raid[0156]
#          /* raid level */
#          | [^/[:space:]]+-[^/[:space:]]+
#          /* lvm logical volume: vg name and lv name*/
#
# mountpoint ::= -
#                /* do not mount */
#                | swap
#                /* swap space */
#                | /[^[:space:]]*
#                /* fully qualified path */
#
# name ::= [^/[:space:]]+
#          /* lvm volume group name */
#
# size ::= [[:digit:]]+%?(-([[:digit:]]+%?)?)?(:resize)?
#          /* size in megabytes or %, possibly given as a range; physical
#           * partitions or lvm logical volumes only */
#          | -[[:digit:]]+%?(:resize)?
#          /* size in megabytes or % given as upper limit; physical partitions
#           * or lvm logical volumes only */
#          | preserve[[:digit:]]+
#          /* do not modify this partition */
#          | [^,:[:space:]]+(:(spare|missing))*(,[^,:[:space:]]+(:(spare|missing))*)*
#          /* devices and options for a raid or lvm vg */
#
# mount_options ::= [^[:space:]]+
#
# filesystem ::= -
#                | swap
#                | [^[:space:]]
#                /* mkfs.xxx must exist */
#
# fs_options ::= .*
#                /* options appended to mkfs.xxx call */
#
#
# $Id$
#
# @author Christian Kern, Michael Tautschnig, Sam Vilain
# @date Sun Jul 23 16:09:36 CEST 2006
#
################################################################################

use Parse::RecDescent;

package FAI;

################################################################################
#
# @brief the name of the device currently being configured, including a prefix
# such as PHY_ or VG_ to indicate physical devices or LVM volume groups. For
# RAID, the entry is only "RAID"
#
################################################################################
$FAI::device = "";

################################################################################
#
# @brief Initialise a new entry in @ref $FAI::configs for a physical disk.
#
# Besides creating the entry in the hash, the fully path of the device is
# computed (see @ref $disk) and it is tested, whether this is a block device.
# The device name is then used to define @ref $FAI::device.
#
# @param $disk Either an integer, occurring in the context of, e.g., disk2, or
# a device name. The latter may be fully qualified, such as /dev/hda, or a short
# name, such as sdb, in which case /dev/ is prepended.
#
################################################################################
sub init_disk_config
{

  # Initialise $disk
  my ($disk) = @_;

  # test $disk for being numeric
  if ( $disk =~ /^\d+$/ )
  {

    # $disk-1 must be a valid index in the map of all disks in the system
    ( scalar( @FAI::disks ) >= $disk )
      or die "this system does not have a physical disk $disk\n";

    # fetch the (short) device name
    $disk = $FAI::disks[ $disk - 1 ];
  }

  # test, whether the device name starts with a / and prepend /dev/, if
  # appropriate
  ( $disk =~ m{^/} ) or $disk = "/dev/$disk";

  # test, whether $disk is a block special device
  ( -b $disk ) or die "$disk is not a valid device name\n";

  # prepend PHY_
  $FAI::device = "PHY_$disk";

  # test, whether this is the first disk_config stanza to configure $disk
  defined( $FAI::configs{$FAI::device} )
    and die "Duplicate configuration for disk $FAI::disks[ $1-1 ]\n";

  # Initialise the entry in $FAI::configs
  $FAI::configs{$FAI::device} = {
    "virtual"    => 0,
    "disklabel"  => "msdos",
    "bootable"   => -1,
    "fstabkey"   => "device",
    "partitions" => {}
  };
}

################################################################################
#
# @brief Initialise the entry of a partition in @ref $FAI::configs
#
# @param $type The type of the partition. It must be either primary or logical.
#
################################################################################
sub init_part_config
{

  # the type of the partition to be created
  my ($type) = @_;

  # type must either be primary or logical, nothing else may be accepted by the
  # parser
  ( $type eq "primary" || $type eq "logical" ) or die "INTERNAL PARSER ERROR\n";

  # check that a physical device is being configured; logical partitions are
  # only supported on msdos disk labels.
  (
    $FAI::device =~ /^PHY_/ && ( $type ne "logical"
      || $FAI::configs{$FAI::device}{"disklabel"} eq "msdos" )
  ) or die "Syntax error: invalid partition type";

  # the index of the new partition
  my $part_number = 0;

  # create a primary partition
  if ( $type eq "primary" )
  {

    # find all previously defined primary partitions
    foreach
      my $part_id ( sort keys %{ $FAI::configs{$FAI::device}{"partitions"} } )
    {

      # break, if the partition has not been created by init_part_config
      defined( $FAI::configs{$FAI::device}{"partitions"}{$part_id}{"size"}
          {"extended"} )
        or last;

      # on msdos disklabels we cannot have more than 4 primary partitions
      last
        if ( $part_id > 4
        && $FAI::configs{$FAI::device}{"disklabel"} eq "msdos" );

      # store the latest index found
      $part_number = $part_id;
    }

    # the next index available - note that $part_number might have been 0
    $part_number++;

    # msdos disk labels don't allow for more than 4 primary partitions
    ( $part_number < 5 || $FAI::configs{$FAI::device}{"disklabel"} ne "msdos" )
      or die "$part_number are too many primary partitions\n";
  }
  else
  {

    # no further checks for the disk label being msdos have to be performed in
    # this branch, it has been ensured above

# find the index of the new partition, initialise it to the highest current index
    foreach
      my $part_id ( sort keys %{ $FAI::configs{$FAI::device}{"partitions"} } )
    {

      # skip primary partitions
      next if ( $part_id < 5 );

      # break, if the partition has not been created by init_part_config
      defined( $FAI::configs{$FAI::device}{"partitions"}{$part_id}{"size"}
          {"extended"} )
        or last;

      # store the latest index found
      $part_number = $part_id;
    }

    # and use the next one available
    $part_number++;

    # if this is the first logical partition, the index must be set to 5 and an
    # extended partition  must be created
    if ( $part_number <= 5 )
    {
      $part_number = 5;

      # the proposed index of the extended partition
      my $extended = 0;

      # find all previously defined primary partitions
      foreach
        my $part_id ( sort keys %{ $FAI::configs{$FAI::device}{"partitions"} } )
      {

        # break, if the partition has not been created by init_part_config
        defined( $FAI::configs{$FAI::device}{"partitions"}{$part_id}{"size"}
            {"extended"} )
          or last;

        # we cannot have more than 4 primary partitions
        last if ( $part_id > 4 );

        # store the latest index found
        $extended = $part_id;
      }

      # the next index available
      $extended++;

      # msdos disk labels don't allow for more than 4 primary partitions
      ( $extended < 5 )
        or die "Too many primary partitions while creating extended\n";

      # mark the entry as an extended partition
      $FAI::configs{$FAI::device}{"partitions"}{$extended}{"size"}{"extended"} =
        1;

      # add the preserve = 0 flag, if it doesn't exist already
      defined( $FAI::configs{$FAI::device}{"partitions"}{$extended}{"size"}
          {"preserve"} )
        or $FAI::configs{$FAI::device}{"partitions"}{$extended}{"size"}
        {"preserve"} = 0;

      # add the resize = 0 flag, if it doesn't exist already
      defined(
        $FAI::configs{$FAI::device}{"partitions"}{$extended}{"size"}{"resize"} )
        or
        $FAI::configs{$FAI::device}{"partitions"}{$extended}{"size"}{"resize"} =
        0;
    }
  }

  # initialise the hash for the partitions, if it doesn't exist already
  # note that it might exists due to options, such as preserve:x,y
  # the initialisation is required for the reference defined next
  defined( $FAI::configs{$FAI::device}{"partitions"}{$part_number} )
    or $FAI::configs{$FAI::device}{"partitions"}{$part_number} = {};

  # set the reference to the current partition
  # the reference is used by all further processing of this config line
  $FAI::partition_pointer =
    ( \%FAI::configs )->{$FAI::device}->{"partitions"}->{$part_number};

  # as we can't compute the index from the reference, we need to store the
  # $part_number explicitly
  $FAI::partition_pointer->{"number"} = $part_number;

  # the partition is not an extended one
  $FAI::partition_pointer->{"size"}->{"extended"} = 0;

  # add the preserve = 0 flag, if it doesn't exist already
  defined( $FAI::partition_pointer->{"size"}->{"preserve"} )
    or $FAI::partition_pointer->{"size"}->{"preserve"} = 0;

  # add the resize = 0 flag, if it doesn't exist already
  defined( $FAI::partition_pointer->{"size"}->{"resize"} )
    or $FAI::partition_pointer->{"size"}->{"resize"} = 0;
}

# have RecDescent do proper error reporting
$::RD_HINT = 1;

################################################################################
#
# @brief The effective implementation of the parser is instantiated here
#
################################################################################
$FAI::Parser = Parse::RecDescent->new(
  q{
    file: line(s?) /\Z/
        {
          $return = 1;
        }
        | <error>

    line: <skip: qr/[ \t]*/> "\\n"
        | <skip: qr/[ \t]*/> comment "\\n"
        | <skip: qr/[ \t]*/> config "\\n"

    comment: /^\s*#.*/

    config: 'disk_config' disk_config_arg
        | volume

    disk_config_arg: 'raid'
        {
          # check, whether raid tools are available
          ( &FAI::in_path( "mdadm" ) == 1 ) or 
            die "mdadm not found in PATH\n";
          $FAI::device = "RAID";
        }
        | /^lvm/
        {
	  ( $FAI::debug > 0 ) and print "Found LVM keyword\n";
          # check, whether lvm tools are available
          ( &FAI::in_path( "lvcreate" ) == 1 ) or 
            die "LVM tools not found in PATH\n";
          # initialise $FAI::device to inform the following lines about the LVM
          # being configured
          $FAI::device = "VG_";
        }
        | 'end'
        {
          # exit config mode
          $FAI::device = "";
        }
        | /^disk(\d+)/
        {
          # check, whether parted is available
          ( &FAI::in_path( "parted" ) == 1 ) or 
            die "parted not found in PATH\n";
          # initialise the entry of the hash corresponding to disk$1
          &FAI::init_disk_config( $1 );
        }
        option(s?)
        | /^\S+/
        {
          # check, whether parted is available
          ( &FAI::in_path( "parted" ) == 1 ) or 
            die "parted not found in PATH\n";
          # initialise the entry of the hash corresponding to $item[1]
          &FAI::init_disk_config( $item[ 1 ] );
        }
        option(s?)

    option: /^preserve:(\d+(,\d+)*)/
        {
          # set the preserve flag for all ids
          $FAI::configs{ $FAI::device }{ "partitions" }{ $_ }{ "size" }{ "preserve" } = 1 foreach ( split( ",", $1 ) );
        }
        | /^resize:(\d+(,\d+)*)/
        {
          # set the resize flag for all ids
          $FAI::configs{ $FAI::device }{ "partitions" }{ $_ }{ "size" }{ "resize" } = 1 foreach ( split( ",", $1 ) );
        }
        | /^disklabel:(msdos|gpt)/
        {
          # set the disk label - actually not only the above, but all types 
          # supported by parted could be allowed, but others are not implemented
          # yet
          $FAI::configs{ $FAI::device }{ "disklabel" } = $1;
        }
        | /^bootable:(\d+)/
        {
          # specify a partition that should get the bootable flag set
          $FAI::configs{ $FAI::device }{ "bootable" } = $1;
          ( $FAI::device =~ /^PHY_(.+)$/ ) or die 
            "INTERNAL ERROR: unexpected device name\n";
          # set the BOOT_DEVICE and BOOT_PARTITION variables
          $FAI::disk_var{ "BOOT_DEVICE" } = $1; 
          $FAI::disk_var{ "BOOT_PARTITION" } = $1 . 
            $FAI::configs{ $FAI::device }{ "bootable" }; 
        }
        | 'virtual'
        {
          # this is a configuration for a virtual disk
          $FAI::configs{ $FAI::device }{ "virtual" } = 1;
        }
        | /^fstabkey:(device|label|uuid)/
        {
          # the information preferred for fstab device identifieres
          $FAI::configs{ $FAI::device }{ "fstabkey" } = $1;
        }

    volume: /^vg\s+/ name devices
        | /^raid([0156])\s+/
        {
          # make sure that this is a RAID configuration
          ( $FAI::device eq "RAID" ) or die "RAID entry invalid in this context\n";
          # initialise RAID entry, if it doesn't exist already
          defined( $FAI::configs{"RAID"} ) or $FAI::configs{"RAID"}{"volumes"} = {};
          # compute the next available index - the size of the entry
          my $vol_id = scalar( keys %{ $FAI::configs{"RAID"}{"volumes"} } );
          # set the RAID type of this volume
          $FAI::configs{"RAID"}{"volumes"}{$vol_id}{"mode"} = $1;
          # initialise the hash of devices
          $FAI::configs{"RAID"}{"volumes"}{$vol_id}{"devices"} = {};
          # set the reference to the current volume
          # the reference is used by all further processing of this config line
          $FAI::partition_pointer = ( \%FAI::configs )->{"RAID"}->{"volumes"}->{$vol_id};
        }
        mountpoint devices filesystem mount_options fs_options
        | type mountpoint size filesystem mount_options fs_options

    type: 'primary'
        {
          # initialise a primary partition
          &FAI::init_part_config( $item[ 1 ] );
        }
        | 'logical'
        {
          # initialise a logical partition
          &FAI::init_part_config( $item[ 1 ] );
        }
        | m{^([^/\s\-]+)-([^/\s\-]+)\s+}
        {
          # set $FAI::device to VG_$1
          $FAI::device = "VG_$1";
          # make sure, the volume group $1 has been defined before
          defined( $FAI::configs{$FAI::device} ) or 
            die "Volume group $1 has not been declared yet.\n";
          # make sure, $2 has not been defined already
          defined( $FAI::configs{$FAI::device}{"volumes"}{$2} ) and 
            die "Logical volume $2 has been defined already.\n";
          # initialise the new hash
          $FAI::configs{$FAI::device}{"volumes"}{$2} = {};
          # initialise the preserve and resize flags
          $FAI::configs{$FAI::device}{"volumes"}{$2}{"size"}{"preserve"} = 0;
          $FAI::configs{$FAI::device}{"volumes"}{$2}{"size"}{"resize"} = 0;
          # set the reference to the current volume
          # the reference is used by all further processing of this config line
          $FAI::partition_pointer = ( \%FAI::configs )->{$FAI::device}->{"volumes"}->{$2};
        }

    mountpoint: '-'
        {
          # this partition should not be mounted
          $FAI::partition_pointer->{ "mountpoint" } = "-";
        }
        | 'swap'
        {
          # this partition is swap space, not mounted
          $FAI::partition_pointer->{ "mountpoint" } = "none";
        }
        | m{^/\S*}
        {
          # set the mount point
          $FAI::partition_pointer->{ "mountpoint" } = $item[ 1 ];
          # mark the bootable partition, if it is not set yet and this is a PHY_
          # device
          if ( $item[ 1 ] eq "/" && $FAI::device =~ /^PHY_(.+)$/ &&
            $FAI::configs{$FAI::device}{"bootable"} == -1 )
          {
            $FAI::configs{$FAI::device}{"bootable"} =
              $FAI::partition_pointer->{"number"};
            # set the BOOT_DEVICE and BOOT_PARTITION variables
            $FAI::disk_var{ "BOOT_DEVICE" } = $1; 
            $FAI::disk_var{ "BOOT_PARTITION" } = $1 . 
              $FAI::configs{ $FAI::device }{ "bootable" };
          }
        }

    name: m{^([^/\s\-]+)}
        {
          # set the device name to VG_ and the name of the volume group
          $FAI::device = "VG_$1";
          # make sure, the volume group $1 not has been defined already
          defined( $FAI::configs{$FAI::device} ) and
            die "Volume group $1 has been defined already.\n";
          # make sure this line is part of an LVM configuration
          ( $FAI::device =~ /^VG_/ ) or
            die "vg is invalid in a non LVM-context.\n";
          # initialise the new hash
          $FAI::configs{$FAI::device}{"volumes"} = {};
          # initialise the list of physical devices
          $FAI::configs{$FAI::device}{"devices"} = ();
          # the rule must not return undef
          1;
        }

    size: /^(\d+%?(-(\d+%?)?)?)(:resize)?\s+/
        {
          # complete the size specification to be a range in all cases
          my $range = $1;
          # the size is fixed
          if( ! defined( $2 ) )
          {
            # make it a range of the form x-x
            $range = "$range-$1";
          }
          elsif( ! defined( $3 ) )
          {
            # range has no upper limit, assume the whole disk
            $range = $range . "100%";
          }
          # enter the range into the hash
          $FAI::partition_pointer->{ "size" }->{ "range" } = $range;
          # set the resize flag, if required
          defined( $4 ) and $FAI::partition_pointer->{ "size" }->{ "resize" } = 1;
        }
        | /^(-\d+%?)(:resize)?\s+/
        {
          # complete the range by assuming 0 as the lower limit 
          $FAI::partition_pointer->{ "size" }{ "range" } = "0$1";
          # set the resize flag, if required
          defined( $2 ) and $FAI::partition_pointer->{ "size" }->{ "resize" } = 1;
        }
        | /^preserve(\d+)\s+/
        {
          # set the preserve flag, if the index of the partition hasn't changed
          ( $1 == $FAI::partition_pointer->{ "number" } ) or die
            "Partition number of to-be-preserved partition $1 changed to $FAI::partition_pointer->{number}\n";
          $FAI::partition_pointer->{ "size" }->{ "preserve" } = 1;
        }
        | <error: invalid partition size near "$text">

    devices: /^([^\d,:\s\-][^,:\s]*(:(spare|missing))*(,[^,:\s]+(:(spare|missing))*)*)/
        {
          # split the device list by ,
          foreach my $dev ( split( ",", $1 ) )
          {
            # match the substrings
            ( $dev =~ /^([^\d,:\s\-][^,:\s]*)(:(spare|missing))*$/ ) or die "INTERNAL PARSER ERROR\n";
            # redefine the device string
            $dev = $1;
            # make $dev a full path name; can't validate device name yet as it
            # might be created later on
            ( $dev =~ m{^/} ) or $dev = "/dev/$dev";
            # options are only valid for RAID
            defined( $2 ) and ( $FAI::device ne "RAID" ) and die "Option $2 invalid in a non-RAID context\n";
            if( $FAI::device eq "RAID" )
            {
              # parse all options
              my $spare = 0;
              my $missing = 0;
              if( defined( $2 ) )
              {
                ( $2 =~ /spare/ ) and $spare = 1;
                ( $2 =~ /missing/ ) and $missing = 1;
              }
              # each device may only appear once
              defined( $FAI::partition_pointer->{"devices"}->{$dev} ) and 
                die "$dev is already part of the RAID volume\n";
              # set the options
              $FAI::partition_pointer->{"devices"}->{$dev}->{"options"} = {
                "spare" => $spare,
                "missing" => $missing
              };
            }
            else
            {
              # create an empty hash for each device
              $FAI::configs{$FAI::device}{"devices"}{$dev} = {};
            }
          }
          1;
        }
        | <error: invalid device spec "$text">

    mount_options: /\S+/
        {
          $FAI::partition_pointer->{ "mount_options" } = $item[ 1 ];
        }

    filesystem: '-'
        {
          $FAI::partition_pointer->{ "filesystem" } = $item[ 1 ];
        }
        | 'swap'
        {
          $FAI::partition_pointer->{ "filesystem" } = $item[ 1 ];
        }
        | /^\S+/
        {
          ( &FAI::in_path("mkfs.$item[1]") == 1 ) or 
            die "unknown/invalid filesystem type $item[1] (mkfs.$item[1] not found in PATH)\n";
          $FAI::partition_pointer->{ "filesystem" } = $item[ 1 ];
        }

    fs_options: /[^;\n]*/
        {
          $FAI::partition_pointer->{ "fs_options" } = $item[ 1 ];
        }
}
);

################################################################################
#
# @brief Parse the data from <$IN> using @ref $FAI::Parser
#
# @param IN file handle for input file, may be STDIN
#
################################################################################
sub run_parser
{
  my ( $IN ) = @_;

  # read <$IN> to a single string (not a list), thus $/ has to be unset
  my $ifs = $/;
  undef $/;
  my $input = <$IN>;
  $/ = $ifs;

  # print the contents of <$IN> for debugging purposes
  ( $FAI::debug > 0 ) and print "Input was:\n" . $input;

  # check for old-style configuration files
  ( $input =~ m{(^|\n)[^\n#]+;} ) and die 
    "Old style configuration files are not supported\n";

  # attempt to parse $input - any error will lead to termination
  defined $FAI::Parser->file($input) or die "Syntax error\n";
}

1;

