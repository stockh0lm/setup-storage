#!/usr/bin/perl -w

use strict;


#
# file ::= <lines> EOF
# 
# lines ::= EOL
#           /* empty lines or whitespace only */
#           | <comment> EOL
#           | <config> EOL
# 
# comment ::= #.*
# 
# config ::= disk_config lvm
#            | disk_config raid
#            | disk_config end
#            | disk_config disk[[:digit:]]+( <option>)*
#            | disk_config [^[:space:]]+( <option>)*
#            /* fully qualified device-path or short form, like hda, whereby full
#             * path is assumed to be /dev/hda */
#            | <volume>
# 
# option ::= /* empty */
#            | preserve:[[:digit:]]+(,[[:digit:]]+)*
#            /* preserve partitions */
#            | resize:[[:digit:]]+(,[[:digit:]]+)*
#            /* attempt to resize partitions */
#            | disklabel:(msdos|sun)
#            /* write a disklabel - default is msdos */
#            | bootable:[[:digit:]]+
#            /* mark a partition bootable, default is / */
#            | virtual
#            /* do not assume the disk to be a physical device, use with xen */
# 
# volume ::= <type> <mountpoint> <size> <filesystem> <mount_options> <fs_options>
#            | vg <name> <size>
#            /* lvm vg */
# 
# type ::= primary
#          /* for physical disks only */
#          | logical
#          /* for physical disks only */
#          | raid[0156]
#          /* raid level */
#          | [^/[:space:]]+-[^/[:space:]]+
#          /* lvm logical volume: vg name and lv name*/
# 
# mountpoint ::= -
#                /* do not mount */
#                | swap
#                /* swap space */
#                | /[^[:space:]]*
#                /* fully qualified path */
# 
# name ::= [^/[:space:]]+
#          /* lvm volume group name */
# 
# size ::= [[:digit:]]+%?(-([[:digit:]]+%?)?)?(:resize)?
#          /* size in megabytes or %, possibly given as a range; physical
#           * partitions or lvm logical volumes only */
#          | -[[:digit:]]+%?(:resize)?
#          /* size in megabytes or % given as upper limit; physical partitions 
#           * or lvm logical volumes only */
#          | preserve[[:digit:]]+
#          /* do not modify this partition */
#          | [^,:[:space:]]+(:(spare|missing))*(,[^,:[:space:]]+(:(spare|missing))*)*
#          /* devices and options for a raid or lvm vg */
#     
# mount_options ::= [^[:space:]]+
# 
# filesystem ::= -
#                | swap
#                | [^[:space:]]
#                /* mkfs.xxx must exist */
# 
# fs_options ::= .*
#                /* options appended to mkfs.xxx call */
#

use Parse::RecDescent;

package FAI;

%FAI::configs = ();

$FAI::device = "";
$FAI::partition_primary_counter = 0;
$FAI::partition_logical_counter = 0;



my $Parser = Parse::RecDescent->new(q{
    file: line(s?) /\Z/
    line: <skip: qr/[ \t]*/> "\\n"
        | <skip: qr/[ \t]*/> comment "\\n"
        | <skip: qr/[ \t]*/> config "\\n"
        #| <error>
    comment: /^\s*#.*/
    config: 'disk_config' disk_config_arg
        | volume
    disk_config_arg: 'raid'
        {
          #check wether raid tools are available
          $FAI::device = "RAID";
        }
        | 'lvm'
        {
          #check wether lvm tools are available
          $FAI::device = "VG_";
        }
        | 'end'
        {
          $FAI::device = "";
        }
        | /^disk(\d+)/
        {
          if( scalar( @FAI::disks ) >= $1 )
          {
            if( $FAI::disks[ $1-1 ] =~ m{^/} )
            {
              $FAI::device = "PHY_" . $FAI::disks[ $1-1 ];
            }
            else
            {
              $FAI::device = "PHY_/dev/" . $FAI::disks[ $1-1 ];
            }
            if( defined( $FAI::configs{ $FAI::device } ) )
            {
              die "Duplicate configuration for disk $FAI::disks[ $1-1 ]\n";
            }
            $FAI::configs{ $FAI::device } = {
              "virtual" => 0,
              "disklabel" => "msdos",
              "bootable" => -1,
              "partitions" => ()
            };
          }
          else
          {
            die "this system does not have a physical $item[1] "
          }
        }
        option(s?)
        | /^\S+/
        {
          # check for valid device name
          if( $item[ 1 ] =~ m{^/} )
          {
            $FAI::device = "PHY_" . $item[ 1 ];
          }
          else
          {
            $FAI::device = "PHY_/dev/" . $item[ 1 ];
          }
          if( defined( $FAI::configs{ $FAI::device } ) )
          {
            die "Duplicate configuration for disk $FAI::disks[ $1-1 ]\n";
          }
          $FAI::configs{ $FAI::device } = {
            "virtual" => 0,
            "disklabel" => "msdos",
            "bootable" => -1,
            "partitions" => {}
          };
        }
        option(s?)
    option: /^preserve:(\d+(,\d+)*)/
        {
          my @ids = split( ",", $1 );
          foreach my $id ( @ids )
          {
            $FAI::configs{ $FAI::device }{ "partitions" }{ $id }{ "size" }{ "preserve" } = 1;
          }
        }
        | /^resize:(\d+(,\d+)*)/
        {
          my @ids = split( ",", $1 );
          foreach my $id ( @ids )
          {
            $FAI::configs{ $FAI::device }{ "partitions" }{ $id }{ "size" }{ "resize" } = 1;
          }
        }
        | /^disklabel:(msdos|sun)/
        {
          $FAI::configs{ $FAI::device }{ "disklabel" } = $1;
        }
        | /^bootable:(\d+)/
        {
          $FAI::configs{ $FAI::device }{ "bootable" } = $1;
        }
        | 'virtual'
        {
          $FAI::configs{ $FAI::device }{ "virtual" } = 1;
        }
    volume: type mountpoint size filesystem mount_options fs_options
        | 'vg' name size
        {
          if( ! $FAI::device =~ /^VG_/ )
          {
            die "vg is invalid in a non LVM-context.\n";
          }
          # TODO create vg
        }
    type: 'primary'
        {
          ( $FAI::device =~ /^PHY_/ ) or die "wrong partition type";
          {
            ( $FAI::partition_primary_counter < 4 || $FAI::configs{ $FAI::device }{ "disklabel" } ne "msdos" ) or die "Too many primary partitions\n";
            $FAI::partition_primary_counter++;
            $FAI::configs{ $FAI::device }{ "partitions" }{ $FAI::partition_primary_counter }= {};
            $FAI::partition_pointer = (\%FAI::configs)->{ $FAI::device }->{ "partitions" }->{ $FAI::partition_primary_counter };
            $FAI::partition_pointer->{ "size" }->{ "extended" } = 0;
            $FAI::partition_pointer->{ "number" } = $FAI::partition_primary_counter;
          }
        }
        | 'logical'
        {
          ( $FAI::device =~ /^PHY_/  && $FAI::configs{ $FAI::device }{ "disklabel" } eq "msdos" ) or die "wrong partition type";
          {
            if( $FAI::partition_logical_counter == 0 )
            {
              ( $FAI::partition_primary_counter < 4 ) or die "Too many primary partitions\n";
              $FAI::partition_primary_counter++;
              $FAI::configs{ $FAI::device }{ "partitions" }{ $FAI::partition_primary_counter }{ "size" }{ "extended" } = 1;
            }
            $FAI::partition_logical_counter++;
            $FAI::configs{ $FAI::device }{ "partitions" }{ $FAI::partition_logical_counter + 4 }= {};
            $FAI::partition_pointer = (\%FAI::configs)->{ $FAI::device }->{ "partitions" }->{ $FAI::partition_logical_counter + 4 };
            $FAI::partition_pointer->{ "size" }->{ "extended" } = 0;
            $FAI::partition_pointer->{ "number" } = $FAI::partition_logical_counter + 4;
          }
        }
        | /^raid[0156]/
        {
        }
        | m{^[^/\s]+-[^/\s]+}
        {
        }
    mountpoint: '-'
        {
          $FAI::partition_pointer->{ "mountpoint" } = "-";
        }
        | 'swap'
        {
          $FAI::partition_pointer->{ "mountpoint" } = "swap";
        }
        | m{^/\S*}
        {
          $FAI::partition_pointer->{ "mountpoint" } = $item[ 1 ];
        }
    name: /^\S+/
    size: /^(\d+%?(-(\d+%?)?)?)(:resize)?\s+/
        {
          my $range = $1;
          if( ! defined( $2 ) )
          {
            $range = $range . "-" . $1;
          }
          elsif( ! defined( $3 ) )
          {
            $range = $range . "100%";
          }
          $FAI::partition_pointer->{ "size" }->{ "range" } = $range;
          if( defined( $4 ) || defined( $FAI::partition_pointer->{ "size" }{ "resize" } ) )
          {
            $FAI::partition_pointer->{ "size" }->{ "resize" } = 1;
          }
          else
          {
            $FAI::partition_pointer->{ "size" }->{ "resize" } = 0;
          }
        }
        | /^(-\d+%?)(:resize)?\s+/
        {
          $FAI::partition_pointer->{ "size" } = {
            "range" => "0" . $1
          };
          if( defined( $2 ) || defined( $FAI::partition_pointer->{ "size" }{ "resize" } ) )
          {
            $FAI::partition_pointer->{ "size" }->{ "resize" } = 1;
          }
          else
          {
            $FAI::partition_pointer->{ "size" }->{ "resize" } = 0;
          }
        }
        | /^preserve(\d+)\s+/
        {
          if( $1 == $FAI::partition_pointer->{ "number" } )
          {
            $FAI::partition_pointer->{ "size" }->{ "preserve" } = 1;
          }
          else
          {
            warn "partition number of to-be-preserved partition $1 changed to " .  $FAI::partition_pointer->{ "number" } . "\n";
          }
        }
        | /^[^\d,:\s\-][^,:\s]*(:(spare|missing))*(,[^,:\s]+(:(spare|missing))*)*\s+/
        {
          if( $FAI::device ne "RAID" )
          {
            warn "invalid within this context\n";
          }
          else
          {
            $FAI::partition_pointer->{ "size" }->{ "range" } = -1;
            $FAI::partition_pointer->{ "size" }->{ "devices" } = $item[ 0 ];
          }
        }
        | <error: invalid partition size near "$text">
    mount_options: /\S+/
        {
          $FAI::partition_pointer->{ "mount_options" } = $item[ 1 ];
        }
    filesystem: '-'
        {
          $FAI::partition_pointer->{ "filesystem" } = $item[ 1 ];
        }
        | 'swap'
        {
          $FAI::partition_pointer->{ "filesystem" } = $item[ 1 ];
        }
        | /^\S+/
        {
          if ( !&FAI::in_path("$item[1]") ) 
          {
             warn "unknown/invalid filesystem type '$item[1]'";
          }
          $FAI::partition_pointer->{ "filesystem" } = $item[ 1 ];
        }
    fs_options: /.*/
});


sub in_path
{
  my ($filesystem) = @_;
  
  my @path_list = split(":", $ENV{"PATH"});

  foreach my $p (@path_list)
  {
    if( -x $p."/mkfs.$filesystem")
    {
      return 1;
    }
  }
  return 0;
    
}

sub print_hash
{
  my ($hash_ref, $k) = @_;
  $k=$k.">";
  foreach my $key (keys %$hash_ref)
  {
    if (ref($hash_ref->{$key}))
    {
      printf "$k Schluessel: ". $key." Wert: "."Hash" ."\n";
      &print_hash($hash_ref->{$key}, $k);
    }
    else
    {
      printf "$k Schluessel: ". $key." Wert: ".$hash_ref->{$key}."\n";
    }

  }
}


my $ifs = $/;
undef $/;
my $input = <STDIN>;
$/ = $ifs;

print "Input was:\n" . $input;

defined $Parser->file( $input ) or die "Syntax error\n";

&print_hash(\%FAI::configs);


1;

