#!/usr/bin/perl -w

#*********************************************************************
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# A copy of the GNU General Public License is available as
# `/usr/share/common-licences/GPL' in the Debian GNU/Linux distribution
# or on the World Wide Web at http://www.gnu.org/copyleft/gpl.html. You
# can also obtain it by writing to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#*********************************************************************

use strict;

################################################################################
#
# @file shdd2-commands
#
# @brief Build the required commands using the config stored in %FAI::configs
#
# $Id$
#
# @author Christian Kern, Michael Tautschnig
# @date Sun Jul 23 16:09:36 CEST 2006
#
################################################################################

package FAI;

################################################################################
#
# @brief Using the configurations from %FAI::configs, a list of commands is
# build
#
# The list is @FAI::commands
#
################################################################################
sub build_commands
{

  # loop through all configs
  foreach my $config ( keys %FAI::configs )
  {

    # TODO implement RAID/LVM support
    if ( $config eq "RAID" || $config =~ /^VG_/ )
    {

      # TODO
      next;
    }

    # configure a physical device
    elsif ( $config =~ /^PHY_(.*)$/ )
    {

      # the device to be configured
      my $disk = $1;

      # the list of partitions that must be preserved
      my @to_preserve = ();

      # the index of the existing extended partiton
      my $extended = -1;

      # find any existing extended partition on msdos disklabels
      if ( $FAI::current_config{$disk}{"disklabel"} eq "msdos" )
      {

        # loop over all existing partitions
        foreach my $part_id (
          sort keys %{ $FAI::current_config{$disk}{"partitions"} } )
        {
          next
            unless ( $FAI::current_config{$disk}{"partitions"}{$part_id}
            {"is_extended"} == 1 );

          # TODO: should be handled properly
          ( $extended == -1 ) or die "INTERNAL ERROR: Can't handle more than 1
          extended partition\n";

          # set the id of the extended partition
          $extended = $part_id;
        }
      }

      # find partitions that should be preserved or resized
      foreach
        my $part_id ( sort keys %{ $FAI::configs{$config}{"partitions"} } )
      {

        next
          unless (
          $FAI::configs{$config}{"partitions"}{$part_id}{"size"}{"preserve"} ==
          1
          || $FAI::configs{$config}{"partitions"}{$part_id}{"size"}{"resize"} ==
          1 );

        # preserved partitions must exist already
        defined( $FAI::current_config{$disk}{"partitions"}{$part_id} )
          or die "$part_id can't be preserved, it does not exist.\n";

        # add $part_id to the list of preserved partitions
        push @to_preserve, $part_id;

        # in case $part_id is a logical partition, the corresponding extended
        # partition must be preserved as well
        if ( $extended > -1
          && $part_id > 4
          && $FAI::current_config{$disk}{"disklabel"} eq "msdos" )
        {
          push @to_preserve, $extended;

          # set $extended to -1 to avoid adding it multiple times; do not rely
          # on $extended later on!
          $extended = -1;
        }
      }

      # sort the list of preserved partitions
      @to_preserve = sort { $a <=> $b } @to_preserve;

      # check, whether a new disk label is required
      if ( $FAI::configs{$config}{'disklabel'} ne
        $FAI::current_config{$disk}{'disklabel'} )
      {

        # A new disk label may only be written if no partitions need to be
        # preserved
        ( scalar(@to_preserve) > 0 )
          and die "Can't change disklabel, partitions are to be preserved!\n";

        # add a command to set the disklabel
        push @FAI::commands, "$FAI::system_commands{'parted'} $disk mklabel"
          . $FAI::configs{$config}{'disklabel'};
      }
      else
      {

        # the disk label is unchanged, now all partitions must be removed unless
        # they are to be preserved
        foreach my $part_id (
          sort keys %{ $FAI::current_config{$disk}{"partitions"} } )
        {

          # partition $part_id is to be preserved, skip it
          if ( $to_preserve[0] == $part_id )
          {

            # and remove it from the list
            shift @to_preserve;
            next;
          }

          # add a command to remove $part_id
          push @FAI::commands,
            "$FAI::system_commands{'parted'} $disk rm $part_id";
        }
      }

      # the byte count where the next parition should start
      my $next_start = 0;

      # generate the commands for resizing or creating partitions
      foreach
        my $part_id ( sort keys %{ $FAI::configs{$config}{"partitions"} } )
      {

        # check, whether $part_id must be preserved; we have checked it for
        # existence above already
        if (
          $FAI::configs{$config}{"partitions"}{$part_id}{"size"}{"preserve"} ==
          1 )
        {

          # the next partition may start after the preserved partition
          $next_start =
            $FAI::current_config{$disk}{"partitions"}{$part_id}{"end_byte"} + 1
            unless ( $FAI::configs{$config}{"disklabel"} eq "msdos"
            && $FAI::configs{$config}{"partitions"}{$part_id}{"size"}
            {"extended"} == 1 );
        }

        # check, whether $part_id must be resized; we have checked it for
        # existence above already
        elsif (
          $FAI::configs{$config}{"partitions"}{$part_id}{"size"}{"resize"} ==
          1 )
        {

          # resizing a partition, which must be formatted later makes no sense
          ( $FAI::current_config{$disk}{"partitions"}{"filesystem"} ne
              $FAI::configs{$config}{"partitions"}{$part_id}{"filesystem"} )
            and die
"Filesystem change has been requested for $part_id, resizing makes no sense\n";

          # compute end byte of the resized partition
          my $part_end =
            $FAI::configs{$config}{"partitions"}{"size"}{"eff_size"} +
            $next_start - 1;

          # build an appropriate command
          push @FAI::commands,
            "$FAI::system_commands{'parted'} $disk resize $part_id $next_start"
            . "B "
            . $part_size . "B";

          # set $next_start unless this is an extended partition
          $next_start = $part_size + 1
            unless ( $FAI::configs{$config}{"disklabel"} eq "msdos"
            && $FAI::configs{$config}{"partitions"}{$part_id}{"size"}
            {"extended"} == 1 );
        }

        # $part_id neither needs to be resized nor preserved, but newly created
        else
        {

          # the type of the partition defaults to primary
          my $part_type = "primary";
          if ( $FAI::configs{$config}{"disklabel"} eq "msdos" )
          {

            # change the partition type to extended or logical as appropriate
            if ( $FAI::configs{$config}{"partitions"}{$part_id}{"size"}
              {"extended"} == 1 )
            {
              $part_type = "extended";
            }
            elsif ( $part_id > 4 )
            {
              $part_type = "logical";
            }
          }

          # compute end byte of the new partition
          my $part_end =
            $FAI::configs{$config}{"partitions"}{$part_id}{"size"}{"eff_size"} +
            $next_start - 1;

          # build a parted command to create the partition
          push @FAI::commands, "$FAI::system_commands{'parted'} $disk mkpart
            $part_type $next_start" . "B " . $part_size . "B";
          $next_start = $part_size + 1
            unless ( $FAI::configs{$config}{"disklabel"} eq "msdos"
            && $FAI::configs{$config}{"partitions"}{$part_id}{"size"}
            {"extended"} == 1 );
        }
      }
    }
    else
    {
      die "INTERNAL ERROR: Invalid config\n";
    }
  }
}

1;

