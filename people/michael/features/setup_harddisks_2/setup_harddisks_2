#!/usr/bin/perl -w

# A disk_config file is read line by line; the exact grammar can be found below,
# using EBNF. A few examples are given to make things more obvious:
#
# # Configure the device /dev/hda
# disk_config hda   preserve:6,7   disklabel:msdos  bootable:3
# # preserve the 6th and the 7th partition. Alternatively, 
# # one could say preserve7 below. The disklabel is msdos, which is the default
# # for x86. Furthermore the 3rd partition is made bootable, which would have
# # happened as well by default as it is mounted as /
# primary /boot     20        rw                  ext3
# # create a primary partition /dev/hda1 with a size of 20 MB and mount it
# # read-write as /boot; it is formatted using ext3 filesystem
# primary swap      1000     sw         swap
# # /dev/hda2 will be a swap space of 1000 MB
# primary /         12000      rw                  ext3  -b 2048
# # /dev/hda3 should be formatted using ext3 filesystem; when calling mkfs.ext3
# # the option "-b 2048" is appended.
# logical /tmp      1000      rw,nosuid		ext3
# # create the logical partition /dev/hda5
# logical /usr      preserve6      rw                  ext3
# logical /var      2000-      rw                  ext3
# # make /dev/hda7 at least 2000 MB
# logical /nobackup 0-	rw                   xfs
# # use mkfs.xfs to format the partition
#
#
# # Create a softRAID
# disk_config raid
# raid1        /    sda1,sdd1  rw,errors=remount-ro    ext2
# # create a RAID-1 on /dev/sda1 and /dev/sdd1, format using mkfs.ext2 and mount
# # it as /
# raid0        -    sdb1,sde1  default                 ext2
# # create a RAID-0 on /dev/sdb1 and /dev/sde1
#
#
# # config an LVM
# disk_config lvm
# pv  my_pv   md2,md3
# # create the physical volume group my_pv on the (RAID) devices /dev/md2 and
# # /dev/md3
# my_pv:_usr	/usr			2048        rw,notail    reiser
# # create the logical volume _usr on the physical volume group my_pv
#
#
#
# complete EBNF grammar:
#
# file ::= <lines> EOF
# 
# lines ::= EOL
#           /* empty lines or whitespace only */
#           | <comment> EOL
#           | <config> EOL
# 
# comment ::= #.*
# 
# config ::= disk_config lvm
#            | disk_config raid
#            | disk_config end
#            | disk_config disk[[:digit:]]+( <option>)*
#            | disk_config [^[:space:]]+( <option>)*
#            /* fully qualified device-path or short form, like hda, whereby full
#             * path is assumed to be /dev/hda */
#            | <volume>
# 
# option ::= /* empty */
#            | preserve:[[:digit:]]+(,[[:digit:]]+)*
#            /* preserve partitions */
#            | disklabel:(msdos|sun)
#            /* write a disklabel - default is msdos */
#            | bootable:[[:digit:]]
#            /* mark a partition bootable, default is / */
# 
# volume ::= <type> <mountpoint> <size> <mount_options> <filesystem> <fs_options>
#            | pv <name> <size>
#            /* lvm pv */
# 
# type ::= primary
#          /* for physical disks only */
#          | logical
#          /* for physical disks only */
#          | raid[015]
#          /* raid level */
#          | [^/[:space:]]+:[^/[:space:]]+
#          /* lvm logical volume: pv name and lv name*/
# 
# mountpoint ::= -
#                /* do not mount */
#                | swap
#                /* swap space */
#                | /[^[:space:]]*
#                /* fully qualified path */
# 
# name ::= [^/[:space:]]+
#          /* lvm volume group name */
# 
# size ::= [[:digit:]]+%?(-[[:digit:]]+%?)?
#          /* size in megabytes or %, possibly given as a range; physical
#           * partitions or lvm logical volumes only */
#          | -[[:digit:]]+%?
#          /* size in megabytes or % given as upper limit; physical partitions 
#           * or lvm logical volumes only */
#          | preserve[[:digit:]]+
#          /* do not modify this partition */
#          | [^,[:space:]]+(,[^,[:space:]])*
#          /* devices for a raid or lvm pv */
#     
# mount_options ::= [^[:space:]]+
# 
# filesystem ::= -
#                | swap
#                | [^[:space:]]
#                /* mkfs.xxx must exist */
# 
# fs_options ::= .*
#                /* options appended to mkfs.xxx call */
#
#
# * TODO - single function to read partition table for a given physical device and store it in
#   some internal format
# * TODO - backend to write things to disk, using e.g. parted (parted -s)
# * TODO - command script:
#   - init_script
#   - make_cmds
#     > make_part_cmds
#     > make_raid_cmds
#     > make_lvm_cmds
#   - make_filesystems
# * TODO - dependencies between LVM/RAID commands -> should be detected by
#   parser/semantic analysis
#   multiple RAID/LVM stanzas, but deps must be satisfied, global RAID-dev counter
# 
# internal format, generated by parser:
# 
# - list of records: line_no[int], mode[string], type[string], size[string],
#   fs[string], fs_opts[string]
# - map to store fstab-info: dev(unique), mount_point(unique), fs, mount_opts 
# 

my $mode = "";
my $line_no = 0;

while(<>)
{
  $line_no++;
  chomp;
  my $line = $_;
  # throw away trailing whitespace
  if( $line =~ /(.*?)\s+$/ )
  {
    $line = $1;
  }

  # comment
  if( $line =~ /^\s*#/ )
  {
    next;
  }
  # blank line
  elsif( $line =~ /^\s*$/ )
  {
    next;
  }
  # disk_config
  elsif( $line =~ /^disk_config\s+(end|lvm|raid|disk\d+(\s+.*)?|\S+(\s+.*)?)$/ )
  {
    my $dev = $1;
    my $dev_options = undef;
    if( $dev =~ /^(\S+)\s+(\S+.*)$/ )
    {
      $dev = $1;
      $dev_options = $2;
    }
    
    # end of disk_config
    if( $dev =~ /^end$/ )
    {
      $mode = "";
    }
    # lvm
    elsif( $dev =~ /^lvm$/ )
    {
      $mode = "lvm";
    }
    # raid
    elsif( $dev =~ /^raid$/ )
    {
      $mode = "raid";
    }
    # n-th of disklist
    elsif( $dev =~ /^disk(\d+)$/ )
    {
      $mode = "phy_";
      my $i = 0;
      foreach my $d ( split( /\s/, $ENV{disklist} ) )
      {
        $i++;
        if( $i == $1 )
        {
          $dev = "/dev/" . $d;
          last;
        }
      }
      $mode = $mode . $dev;
    }
    # device name, full path name given
    elsif( $dev =~ /^\// )
    {
      $mode = "phy_" . $dev;
    }
    # device name, short form
    else
    {
      $mode = "phy_/dev/" . $dev;
    }

    # parse options
    if( $mode =~ /^phy/ && defined( $dev_options ) )
    {
      foreach my $o ( split( /\s+/, $dev_options ) )
      {
        if( $o =~ /^preserve:\d+(,\d+)*$/ )
        {
        }
        elsif( $o =~ /^disklabel:(msdos|sun)$/ )
        {
        }
        elsif( $o =~ /^bootable:\d+$/ )
        {
        }
        else
        {
          die "Syntax error in line " . $line_no . " - invalid option " . $o . "\n";
        }
      }
    }
    elsif( defined( $dev_options ) )
    {
      die "Syntax error in line " . $line_no . "\n";
    } 
  }
  # volume
  else
  {
    my $type = "";
    my $mountpoint = "";
    my $size = "";
    my $mount_options = "";
    my $filesystem = "";
    my $fs_options = "";
    # volume group
    if( $mode eq "lvm" && $line =~ /^pv\s+([^\/\s]+)\s+(\S+)$/ )
    {
      $type = "pv";
      $mountpoint = $1;
      $size = $2;
    }
    # physical partition
    elsif( $mode =~ /^phy/ && $line =~ /^(primary|logical)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)(\s+(.*))?$/ )
    {
      $type = $1;
      $mountpoint = $2;
      $size = $3;
      $mount_options = $4;
      $filesystem = $5;
      $fs_options = $7;
    }
    # RAID definition
    elsif( $mode eq "raid" && $line =~ /^(raid[015])\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)(\s+(.*))?$/ )
    {
      $type = $1;
      $mountpoint = $2;
      $size = $3;
      $mount_options = $4;
      $filesystem = $5;
      $fs_options = $7;
    }
    # logical volume
    elsif( $mode eq "lvm" && $line =~ /^(\S+:\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)(\s+(.*))?$/ )
    {
      $type = $1;
      $mountpoint = $2;
      $size = $3;
      $mount_options = $4;
      $filesystem = $5;
      $fs_options = $7;
    }
    else
    {
      die "Syntax error in line " . $line_no . "\n";
    }

    # test for valid mount point
    if( $type ne "pv" && $mountpoint =~ /^(-|swap|\/(\S+)?)$/ )
    {
    }
    elsif( $type eq "pv" )
    {
    }
    else
    {
      die "Syntax error in line " . $line_no . " - invalid mount point " . $mountpoint . "\n";
    }
    
    # test valid size format
    if( ( $type eq "pv" || $mode eq "raid" ) && $size =~ /^[^,\s]+(,[^,\s]+)*$/ )
    {
    }
    elsif( ( $mode =~ /^phy/ || $type =~ /\S+:\S+/ ) && ( $size =~ /^(\d+%?(-(\d+%?)?)?|-\d+%?)$/ ) )
    {
    }
    elsif( $mode =~ /^phy/ && ( $size =~ /^preserve\d+$/ ) )
    {
    }
    else
    {
      if( $type eq "pv" || $mode eq "raid" )
      {
        die "Syntax error in line " . $line_no . " - invalid device name\n";
      }
      else
      {
        die "Syntax error in line " . $line_no . " - invalid size\n";
      }
    }

    # make sure that filesystem creator exists
    if( $type ne "pv" )
    {
      if( $filesystem =~ /^(-|swap)$/ )
      {
      }
      else
      {
        # TODO - test for existance of mkfs.$filesystem
      }
    } 

    if( $type =~ /\S+:\S+/ )
    {
      # TODO - verify that pv name has been defined already
    }
  }
}
      

