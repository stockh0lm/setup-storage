#!/usr/bin/perl -w

# A disk_config file is read line by line; the exact grammar can be found below,
# using EBNF. A few examples are given to make things more obvious:
#
# # Configure the device /dev/hda
# disk_config hda   preserve:6,7   disklabel:msdos  bootable:3
# # preserve the 6th and the 7th partition. Alternatively, 
# # one could say preserve7 below. The disklabel is msdos, which is the default
# # for x86. Furthermore the 3rd partition is made bootable, which would have
# # happened as well by default as it is mounted as /
# primary /boot     20-100        ext3            rw
# # create a primary partition /dev/hda1 with a size between 20 and 100 MB and mount it
# # read-write as /boot; it is formatted using ext3 filesystem
# primary swap      1000     swap       sw
# # /dev/hda2 will be a swap space of 1000 MB
# primary /         12000      ext3           rw        -b 2048
# # /dev/hda3 should be formatted using ext3 filesystem; when calling mkfs.ext3
# # the option "-b 2048" is appended.
# logical /tmp      1000      ext3            rw,nosuid
# # create the logical partition /dev/hda5
# logical /usr      preserve6      ext3          rw
# logical /var      10%-      ext3               rw
# # make /dev/hda7 at least 10% of the disk size
# logical /nobackup 0-	      xfs                rw
# # use mkfs.xfs to format the partition
#
# # Configure the virtual device /dev/sda (for, e.g., Xen setups), all
# # partitions are primary and sizes are ignored (so one could as well specify
# # anything other than 0)
# disk_config sda virtual
# primary /boot     0            ext3                 rw
# primary /         0            ext3                 rw
# primary /tmp      0            ext3                 rw
# primary /usr      0            ext3                 rw
# primary /var      0            ext3                 rw
#
# # resizing partitions is possible by appending :resize to any given size
# disk_config /dev/scsi/host0/bus0/target1/lun0 
# primary /      3000-6000:resize         ext3         rw
# # resize to any value between 3000 and 6000 MB, as limited by the disk size,
# # the desired sizes of the other partitions, and the data on the partition
# primary /tmp   1000                     ext3         rw
#
# # Create a softRAID
# disk_config raid
# raid1        /    sda1,sdd1  ext2        rw,errors=remount-ro
# # create a RAID-1 on /dev/sda1 and /dev/sdd1, format using mkfs.ext2 and mount
# # it as /
# raid0        -    disk2.2,sdc1,sde1:spare:missing  ext2       default
# # create a RAID-0 on the second partition of the second disk, /dev/sdc1, and
# # /dev/sde1 as a spare partition, which (may?) me missing
#
#
# # config an LVM
# disk_config lvm
# vg  my_vg   md2,md3
# # create the physical volume group my_vg on the (RAID) devices /dev/md2 and
# # /dev/md3
# my_vg-_usr	/usr			2048        reiser        rw,notail
# # create the logical volume _usr on the physical volume group my_vg
#
#
#
# complete EBNF grammar:
#
# file ::= <lines> EOF
# 
# lines ::= EOL
#           /* empty lines or whitespace only */
#           | <comment> EOL
#           | <config> EOL
# 
# comment ::= #.*
# 
# config ::= disk_config lvm
#            | disk_config raid
#            | disk_config end
#            | disk_config disk[[:digit:]]+( <option>)*
#            | disk_config [^[:space:]]+( <option>)*
#            /* fully qualified device-path or short form, like hda, whereby full
#             * path is assumed to be /dev/hda */
#            | <volume>
# 
# option ::= /* empty */
#            | preserve:[[:digit:]]+(,[[:digit:]]+)*
#            /* preserve partitions */
#            | disklabel:(msdos|sun)
#            /* write a disklabel - default is msdos */
#            | bootable:[[:digit:]]
#            /* mark a partition bootable, default is / */
#            | virtual
#            /* do not assume the disk to be a physical device, use with xen */
# 
# volume ::= <type> <mountpoint> <size> <filesystem> <mount_options> <fs_options>
#            | vg <name> <size>
#            /* lvm vg */
# 
# type ::= primary
#          /* for physical disks only */
#          | logical
#          /* for physical disks only */
#          | raid[015]
#          /* raid level */
#          | [^/[:space:]]+-[^/[:space:]]+
#          /* lvm logical volume: vg name and lv name*/
# 
# mountpoint ::= -
#                /* do not mount */
#                | swap
#                /* swap space */
#                | /[^[:space:]]*
#                /* fully qualified path */
# 
# name ::= [^/[:space:]]+
#          /* lvm volume group name */
# 
# size ::= [[:digit:]]+%?(-[[:digit:]]+%?)?(:resize)?
#          /* size in megabytes or %, possibly given as a range; physical
#           * partitions or lvm logical volumes only */
#          | -[[:digit:]]+%?(:resize)?
#          /* size in megabytes or % given as upper limit; physical partitions 
#           * or lvm logical volumes only */
#          | preserve[[:digit:]]+
#          /* do not modify this partition */
#          | [^,:[:space:]]+(:(spare|missing))*(,[^,:[:space:]]+(:(spare|missing))*)*
#          /* devices and options for a raid or lvm vg */
#     
# mount_options ::= [^[:space:]]+
# 
# filesystem ::= -
#                | swap
#                | [^[:space:]]
#                /* mkfs.xxx must exist */
# 
# fs_options ::= .*
#                /* options appended to mkfs.xxx call */
#
#
# * TODO - single function to read partition table for a given physical device and store it in
#   some internal format - /sbin/parted -s /dev/hda unit B print might be
#   helpful
# * TODO - backend to write things to disk, using e.g. parted (parted -s)
# * TODO - test mode, regression test suite
# * TODO - command script:
#   - init_script
#   - make_cmds
#     > make_part_cmds
#     > make_raid_cmds
#     > make_lvm_cmds
#   - make_filesystems
# * TODO - dependencies between LVM/RAID commands -> should be detected by
#   parser/semantic analysis
#   multiple RAID/LVM stanzas, but deps must be satisfied, global RAID-dev counter
#
# * suggestions for modifications of the above format
#   - put options on a separate line
#   - size specification via size_sda1
#   - size specs by RAM size
#   - options for lvcreate (e.g. physical volume)
#
#
# internal format, generated by parser:
# 
# - list of records: line_no[int], mode[string], type[string], size[string],
#   fs[string], fs_opts[string]
# - map to store fstab-info: dev(unique), mount_point(unique), fs, mount_opts 
# 

my $mode = "";
my $line_no = 0;

while(<>)
{
  $line_no++;
  chomp;
  my $line = $_;
  # throw away trailing whitespace
  if( $line =~ /(.*?)\s+$/ )
  {
    $line = $1;
  }

  # comment
  if( $line =~ /^\s*#/ )
  {
    next;
  }
  # blank line
  elsif( $line =~ /^\s*$/ )
  {
    next;
  }
  # disk_config
  elsif( $line =~ /^disk_config\s+(end|lvm|raid|disk\d+(\s+.*)?|\S+(\s+.*)?)$/ )
  {
    my $dev = $1;
    my $dev_options = undef;
    # additional options appended
    if( $dev =~ /^(\S+)\s+(\S+.*)$/ )
    {
      $dev = $1;
      $dev_options = $2;
    }
    # end of disk_config
    if( $dev =~ /^end$/ )
    {
      $mode = "";
    }
    # lvm
    elsif( $dev =~ /^lvm$/ )
    {
      $mode = "lvm";
    }
    # raid
    elsif( $dev =~ /^raid$/ )
    {
      $mode = "raid";
    }
    # n-th of disklist
    elsif( $dev =~ /^disk(\d+)$/ )
    {
      $mode = "phy_";
      my $i = 0;
      foreach my $d ( split( /\s/, $ENV{disklist} ) )
      {
        $i++;
        if( $i == $1 )
        {
          $dev = "/dev/" . $d;
          last;
        }
      }
      $mode = $mode . $dev;
    }
    # device name, full path name given
    elsif( $dev =~ /^\// )
    {
      $mode = "phy_" . $dev;
    }
    # device name, short form
    else
    {
      $mode = "phy_/dev/" . $dev;
    }

    # parse options
    if( $mode =~ /^phy/ && defined( $dev_options ) )
    {
      foreach my $o ( split( /\s+/, $dev_options ) )
      {
        if( $o =~ /^preserve:\d+(,\d+)*$/ )
        {
        }
        elsif( $o =~ /^disklabel:(msdos|sun)$/ )
        {
        }
        elsif( $o =~ /^bootable:\d+$/ )
        {
        }
        elsif( $o =~ /^virtual$/ )
        {
        }
        else
        {
          die "Syntax error in line " . $line_no . " - invalid option " . $o . "\n";
        }
      }
    }
    elsif( defined( $dev_options ) )
    {
      die "Syntax error in line " . $line_no . "\n";
    } 
  }
  # volume
  else
  {
    my $type = "";
    my $mountpoint = "";
    my $size = "";
    my $mount_options = "";
    my $filesystem = "";
    my $fs_options = "";
    # volume group
    if( $mode eq "lvm" && $line =~ /^vg\s+([^\/\s]+)\s+(\S+)$/ )
    {
      $type = "vg";
      $mountpoint = $1;
      $size = $2;
    }
    # physical partition
    elsif( $mode =~ /^phy/ && $line =~ /^(primary|logical)\s+(\S+)\s+(\S+)\s+([^,\s]+)\s+(\S+)(\s+(.*))?$/ )
    {
      $type = $1;
      $mountpoint = $2;
      $size = $3;
      $filesystem = $4;
      $mount_options = $5;
      $fs_options = $7;
    }
    # RAID definition
    elsif( $mode eq "raid" && $line =~ /^(raid[015])\s+(\S+)\s+(\S+)\s+([^,\s]+)\s+(\S+)(\s+(.*))?$/ )
    {
      $type = $1;
      $mountpoint = $2;
      $size = $3;
      $filesystem = $4;
      $mount_options = $5;
      $fs_options = $7;
    }
    # logical volume
    elsif( $mode eq "lvm" && $line =~ /^(\S+\-\S+)\s+(\S+)\s+(\S+)\s+([^,\s]+)\s+(\S+)(\s+(.*))?$/ )
    {
      $type = $1;
      $mountpoint = $2;
      $size = $3;
      $filesystem = $4;
      $mount_options = $5;
      $fs_options = $7;
    }
    else
    {
      die "Syntax error in line " . $line_no . "\n";
    }

    # test for valid mount point
    if( $type ne "vg" && $mountpoint =~ /^(-|swap|\/(\S+)?)$/ )
    {
    }
    elsif( $type eq "vg" )
    {
    }
    else
    {
      die "Syntax error in line " . $line_no . " - invalid mount point " . $mountpoint . "\n";
    }
    
    # test valid size format
    if( $type eq "vg" &&  $size =~ /^[^,:\s]+(,[^,:\s]+)*$/ )
    {
    }
    elsif( $mode eq "raid" && $size =~ /^[^,:\s]+(:(spare|missing))*(,[^,\s]+(:(spare|missing))*)*$/ )
    {
    }
    elsif( ( $mode =~ /^phy/ || $type =~ /\S+\-\S+/ ) && ( $size =~ /^(\d+%?(-(\d+%?)?)?|-\d+%?)(:resize)?$/ ) )
    {
    }
    elsif( $mode =~ /^phy/ && ( $size =~ /^preserve\d+$/ ) )
    {
    }
    else
    {
      if( $type eq "vg" || $mode eq "raid" )
      {
        die "Syntax error in line " . $line_no . " - invalid device name\n";
      }
      else
      {
        die "Syntax error in line " . $line_no . " - invalid size\n";
      }
    }

    # make sure that filesystem creator exists
    if( $type ne "vg" )
    {
      if( $filesystem =~ /^(-|swap)$/ )
      {
      }
      else
      {
        # TODO - test for existance of mkfs.$filesystem
      }
    } 

    if( $type =~ /\S+\-\S+/ )
    {
      # TODO - verify that vg name has been defined already
    }
  }
}
      

