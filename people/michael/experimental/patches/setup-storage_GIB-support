2010-02-21  Michael Tautschnig  <mt@debian.org>

	* setup-storage/Parser.pm: Ignore 'i' in GiB, MiB, etc. and treat those units
		like GB, MB, etc.
	* setup-storage/Sizes.pm: Use MiB instead of MB internally.
	* setup-storage.8: Update syntax.
Index: trunk/lib/setup-storage/Parser.pm
===================================================================
--- trunk.orig/lib/setup-storage/Parser.pm
+++ trunk/lib/setup-storage/Parser.pm	
@@ -290,7 +290,7 @@
 
 ################################################################################
 #
-# @brief This function converts different sizes to Mbyte
+# @brief This function converts different sizes to MiB
 #
 # @param $val is the number with its unit
 #
@@ -298,15 +298,22 @@
 sub convert_unit
 {
   my ($val) = @_;
-  ($val =~ /^(\d+(\.\d+)?)([kMGTP%]?)(B)?\s*$/) or
-    &FAI::internal_error("convert_unit $val");
-  $val = $1 * (1 / 1024) * (1 / 1024) if ($3 eq "" && defined ($4) && $4 eq "B");
-  $val = $1 * (1 / 1024) if ($3 eq "k");
-  $val = $1 if ($3 eq "M");
-  $val = $1 * 1024 if ($3 eq "G");
-  $val = $1 * (1024 * 1024) if ($3 eq "T");
-  $val = $1 * (1024 * 1024 * 1024) if ($3 eq "P");
+
+  ## don't warn for now, G/GiB/GB are all treated the same way
+  ## ($val =~ /([kKMGTP])\s*$/) and
+  ##   warn "Using $1 as size modifier is deprecated, please use $1iB or $1B
+  ##   instead; in future releases these will be treated as different modifiers\n";
+
   # % is returned as is
+  if ($val =~ /^(\d+(\.\d+)?)%\s*$/) { 1; }
+  elsif ($val =~ /^(\d+(\.\d+)?)B\s*$/) { $val = $1 * (1 / 1024) * (1 / 1024); }
+  elsif ($val =~ /^(\d+(\.\d+)?)[kK](i)?(B)?\s*$/) { $val = $1 * (1 / 1024); }
+  elsif ($val =~ /^(\d+(\.\d+)?)M(i)?(B)?\s*$/) { $val = $1; }
+  elsif ($val =~ /^(\d+(\.\d+)?)G(i)?(B)?\s*$/) { $val = $1 * 1024; }
+  elsif ($val =~ /^(\d+(\.\d+)?)T(i)?(B)?\s*$/) { $val = $1 * (1024 * 1024); }
+  elsif ($val =~ /^(\d+(\.\d+)?)P(i)?(B)?\s*$/) { $val = $1 * (1024 * 1024 * 1024); }
+  else { &FAI::internal_error("convert_unit $val"); }
+
   return $val;
 }
 
@@ -623,7 +630,7 @@
           1;
         }
 
-    size: /^(\d+[kMGTP%]?(-(\d+[kMGTP%]?)?)?)(:resize)?\s+/
+    size: /^(\d+[kMGTP%iB]*(-(\d+[kMGTP%iB]*)?)?)(:resize)?\s+/
         {
           # complete the size specification to be a range in all cases
           my $range = $1;
@@ -641,7 +648,9 @@
 
           # convert the units, if necessary
           my ($min, $max) = split (/-/, $range);
+          $min .= "MiB" if ($min =~ /\d\s*$/);
           $min   = &FAI::convert_unit($min);
+          $max .= "MiB" if ($max =~ /\d\s*$/);
           $max   = &FAI::convert_unit($max);
           $range = "$min-$max";
           # enter the range into the hash
@@ -652,13 +661,15 @@
             $FAI::configs{$FAI::device}{preserveparts} = 1;
           }
         }
-        | /^(-\d+[kMGTP%]?)(:resize)?\s+/
+        | /^(-\d+[kMGTP%iB]*)(:resize)?\s+/
         {
           # complete the range by assuming 0 as the lower limit 
           my $range = "0$1";
           # convert the units, if necessary
           my ($min, $max) = split (/-/, $range);
+          $min .= "MiB" if ($min =~ /\d\s*$/);
           $min   = &FAI::convert_unit($min);
+          $max .= "MiB" if ($max =~ /\d\s*$/);
           $max   = &FAI::convert_unit($max);
           $range = "$min-$max";
           # enter the range into the hash
Index: trunk/lib/setup-storage/Sizes.pm
===================================================================
--- trunk.orig/lib/setup-storage/Sizes.pm
+++ trunk/lib/setup-storage/Sizes.pm	
@@ -236,7 +236,7 @@
       # reference to the size of the current logical volume
       my $lv_size = (\%FAI::configs)->{$config}->{volumes}->{$lv}->{size};
       # get the effective sizes (in Bytes) from the range
-      my ($start, $end) = &FAI::make_range($lv_size->{range}, "${vg_size}MB");
+      my ($start, $end) = &FAI::make_range($lv_size->{range}, "${vg_size}MiB");
       # make them MB
       $start /= 1024.0 * 1024.0;
       $end /= 1024.0 * 1024.0;
@@ -274,7 +274,7 @@
 
       # get the range again
       my ($start, $end) =
-      &FAI::make_range($FAI::configs{$config}{volumes}{$lv}{size}{range}, "${vg_size}MB");
+      &FAI::make_range($FAI::configs{$config}{volumes}{$lv}{size}{range}, "${vg_size}MiB");
       # make them MB
       $start /= 1024.0 * 1024.0;
       $end /= 1024.0 * 1024.0;
@@ -666,7 +666,7 @@
       $FAI::device = $config;
       &FAI::init_part_config("primary");
       $FAI::configs{$config}{gpt_bios_part} = $FAI::partition_pointer->{number};
-      my $s = &FAI::convert_unit("120k");
+      my $s = &FAI::convert_unit("120KiB");
       # enter the range into the hash
       $FAI::partition_pointer->{size}->{range} = "$s-$s";
       # set proper defaults
@@ -721,9 +721,9 @@
         ($next_start, $min_req_total_space) = &FAI::do_partition_real($part_id, 
           $config, $disk, $next_start, $min_req_total_space, \@worklist);
 
-        # msdos does not support partitions larger than 2TB
-        ($part->{size}->{eff_size} > (&FAI::convert_unit("2TB") * 1024.0 *
-            1024.0)) and die "msdos disklabel does not support partitions > 2TB, please use disklabel:gpt or gpt-bios\n"
+        # msdos does not support partitions larger than 2TiB
+        ($part->{size}->{eff_size} > (&FAI::convert_unit("2TiB") * 1024.0 *
+            1024.0)) and die "msdos disklabel does not support partitions > 2TiB, please use disklabel:gpt or gpt-bios\n"
           if ($FAI::configs{$config}{disklabel} eq "msdos");
         # partition done
         shift @worklist;
Index: trunk/man/setup-storage.8
===================================================================
--- trunk.orig/man/setup-storage.8
+++ trunk/man/setup-storage.8	
@@ -318,15 +318,19 @@
 .br
 
 
-size ::= [[:digit:]]+[kMGTP%]?(-([[:digit:]]+[kMGTP%]?)?)?(:resize)?
+size ::= [[:digit:]]+[kKMGTP%iB]*(-([[:digit:]]+[kKMGTP%iB]*)?)?(:resize)?
 .br
-         /* size in kilo, mega (default), giga, tera or petabytes or %,
+         /* size in kilo (KiB), mega (default, MiB), giga (GiB), tera (TiB) or
+.br
+          * petabytes (PiB) or %, possibly given as a range; physical
+.br
+          * partitions or lvm logical volumes only; in future releases KB, MB,
 .br
-          * possibly given as a range; physical
+          * GB, ... will be treated as 1000 instead of 1024 (KiB, MiB, GiB, ...)
 .br
-          * partitions or lvm logical volumes only; */
+          * multipliers */
 .br
-         | -[[:digit:]]+[kMGTP%]?(:resize)?
+         | -[[:digit:]]+[kKMGTP%iB]*(:resize)?
 .br
          /* size in kilo, mega (default), giga, tera or petabytes or %,
 .br
@@ -405,10 +409,10 @@
 Preserve the 6th and the 7th partition. The disklabel is msdos which is the default
 for x86. Furthermore the 3rd partition is made bootable.
 .IP \(bu
-Create a primary partition /dev/hda1 with a size between 20 and 100 MB and mount it
+Create a primary partition /dev/hda1 with a size between 20 and 100 MiB and mount it
 read-write as /boot; it is formatted using ext3 filesystem.
 .IP \(bu
-/dev/hda2 will be a swap space of 1000 MB
+/dev/hda2 will be a swap space of 1000 MiB
 .IP \(bu
 /dev/hda3 should be formatted using ext3 filesystem; when calling mkfs.ext3
 the option "\-b 2048" is appended.
