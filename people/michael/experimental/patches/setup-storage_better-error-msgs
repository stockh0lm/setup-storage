2009-06-13  Michael Tautschnig  <mt@debian.org>

	* setup-storage, setup-storage/Sizes.pm: Properly handle -h, early check for
		unset (but necessary) environment variables, print full device names in
		several error/warning messages instead of the partition id only.
Index: trunk/bin/setup-storage
===================================================================
--- trunk.orig/bin/setup-storage
+++ trunk/bin/setup-storage	
@@ -56,8 +56,10 @@
 
 # command line parameter handling
 use Getopt::Std;
+$main::VERSION = $version;
+$Getopt::Std::STANDARD_HELP_VERSION = 1;
 our ($opt_X, $opt_f, $opt_h, $opt_d); # the variables for getopt
-&getopts('Xf:hd') || die <<EOF;
+(&getopts('Xf:hd') && !$opt_h) || die <<EOF;
 setup-storage version $version
 
 USAGE: [-X]                     no test, your harddisks will be formated
@@ -67,17 +69,19 @@
        [-h]                     print this help message
 EOF
 
-# $disklist must be provided by the environment
-defined ($ENV{disklist}) or die "Environment variable disklist is not set\n";
-
 ################################################################################
 #
 # @brief Really write any changes to disk
 #
 ################################################################################
-$FAI::no_dry_run = 0;
-$opt_X and $FAI::no_dry_run = 1;
-$opt_X or warn "setup-harddisks is running in test-only mode\n";
+if ($opt_X) {
+  # we use $ENV{LOGDIR} later on, make sure it is actually set
+  defined ($ENV{LOGDIR}) or die "Environment variable LOGDIR is not set\n";
+  $FAI::no_dry_run = 1;
+} else {
+  warn "setup-harddisks is running in test-only mode\n";
+  $FAI::no_dry_run = 0;
+}
 
 # include all subparts, which are part of the FAI perl package
 use lib "/usr/share/fai/setup-storage/";
@@ -92,11 +96,18 @@
 # enable debug mode, if requested using -d
 $opt_d and $FAI::debug = 1;
 
+# $disklist must be provided by the environment
+defined ($ENV{disklist}) or die "Environment variable disklist is not set\n";
+@FAI::disks = split( /\n/, $ENV{disklist} );
+print "disklist was: $ENV{disklist}\n" if ($FAI::debug);
+
 # the config source file
 my $config_file = undef;
 # use the config file, if given
 open($config_file, $opt_f) or die "Failed to open config file $opt_f\n" if ($opt_f);
 unless ($opt_f) {
+  defined ($ENV{classes}) or
+    die "Environment variable classes is not set and -f was not given\n";
   # see which class file to use
   foreach my $classfile (reverse split(/\s+/, $ENV{classes})) {
     next unless (-r "$ENV{FAI}/disk_config/$classfile");
Index: trunk/lib/setup-storage/Init.pm
===================================================================
--- trunk.orig/lib/setup-storage/Init.pm
+++ trunk/lib/setup-storage/Init.pm	
@@ -58,8 +58,7 @@
 # @brief The lists of disks of the system
 #
 ################################################################################
-@FAI::disks = split( /\n/, $ENV{disklist} );
-( $FAI::debug > 0 ) and print "disklist was: $ENV{disklist}\n";
+@FAI::disks = ();
 
 ################################################################################
 #
Index: trunk/lib/setup-storage/Sizes.pm
===================================================================
--- trunk.orig/lib/setup-storage/Sizes.pm
+++ trunk/lib/setup-storage/Sizes.pm	
@@ -301,26 +301,30 @@
 ################################################################################
 sub do_partition_preserve {
 
-  my ($part_id, $config, $current_disk, $next_start, $min_req_total_space) = @_;
+  my ($part_id, $config, $disk, $next_start, $min_req_total_space) = @_;
+  # reference to the current disk config
+  my $current_disk = $FAI::current_config{$disk};
 
   # reference to the current partition
   my $part = (\%FAI::configs)->{$config}->{partitions}->{$part_id};
+  # full device name
+  my $part_dev_name = &FAI::make_device_name($disk, $part_id);
 
   # a partition that should be preserved must exist already
   defined($current_disk->{partitions}->{$part_id})
-    or die "$part_id can't be preserved, it does not exist.\n";
+    or die "$part_dev_name can't be preserved, it does not exist.\n";
 
   my $curr_part = $current_disk->{partitions}->{$part_id};
 
   ($next_start > $curr_part->{begin_byte})
-    and die "Previous partitions overflow begin of preserved partition $part_id\n";
+    and die "Previous partitions overflow begin of preserved partition $part_dev_name\n";
 
   # get what the user desired
   my ($start, $end) = &FAI::make_range($part->{size}->{range},
     $current_disk->{size} . "B");
   ($start > $curr_part->{count_byte} || $end < $curr_part->{count_byte})
-    and warn "Preserved partition $part_id retains size " .
-      $curr_part->{count_byte} . "\n";
+    and warn "Preserved partition $part_dev_name retains size " .
+      $curr_part->{count_byte} . "B\n";
 
   # set the effective size to the value known already
   $part->{size}->{eff_size} = $curr_part->{count_byte};
@@ -346,7 +350,7 @@
         % ($current_disk->{sector_size} *
           $current_disk->{bios_sectors_per_track} *
           $current_disk->{bios_heads})) or 
-      warn "Preserved partition $part_id does not end at a cylinder boundary, parted may fail to restore the partition!\n";
+      warn "Preserved partition $part_dev_name does not end at a cylinder boundary, parted may fail to restore the partition!\n";
 
     # add one head of disk usage if this is a logical partition
     $min_req_total_space += $current_disk->{bios_sectors_per_track} *
@@ -355,7 +359,7 @@
     # make sure we don't change extended partitions to ordinary ones and
     # vice-versa
     ($part->{size}->{extended} == $curr_part->{is_extended})
-      or die "Preserved partition $part_id can't change extended/normal setting\n";
+      or die "Preserved partition $part_dev_name can't change extended/normal setting\n";
 
     # extended partitions consume no space
     if ($part->{size}->{extended}) {
@@ -373,7 +377,7 @@
     $FAI::configs{$config}{disklabel} eq "gpt-bios") {
     (0 == ($current_disk->{partitions}{$part_id}{end_byte} + 1)
         % $current_disk->{sector_size})
-      or die "Preserved partition $part_id does not end at a sector boundary\n";
+      or die "Preserved partition $part_dev_name does not end at a sector boundary\n";
   }
 
   return ($next_start, $min_req_total_space);
@@ -441,8 +445,9 @@
 ################################################################################
 sub do_partition_real {
 
-  my ($part_id, $config, $current_disk, $next_start, $min_req_total_space,
-    $worklist) = @_;
+  my ($part_id, $config, $disk, $next_start, $min_req_total_space, $worklist) = @_;
+  # reference to the current disk config
+  my $current_disk = $FAI::current_config{$disk};
 
   # reference to the current partition
   my $part = (\%FAI::configs)->{$config}->{partitions}->{$part_id};
@@ -512,7 +517,8 @@
 
     # the next boundary is closer than the minimal space that we need
     ($available_space < $min_req_space)
-      and die "Insufficient space available for partition $part_id\n";
+      and die "Insufficient space available for partition " .
+        &FAI::make_device_name($disk, $part_id) . "\n";
 
     # the new size
     my $scaled_size = $end;
@@ -702,7 +708,7 @@
       # the partition $part_id must be preserved
       if ($part->{size}->{preserve}) {
         ($next_start, $min_req_total_space) = &FAI::do_partition_preserve($part_id, 
-          $config, $current_disk, $next_start, $min_req_total_space);
+          $config, $disk, $next_start, $min_req_total_space);
 
         # partition done
         shift @worklist;
@@ -732,7 +738,7 @@
         shift @worklist;
       } else {
         ($next_start, $min_req_total_space) = &FAI::do_partition_real($part_id, 
-          $config, $current_disk, $next_start, $min_req_total_space, \@worklist);
+          $config, $disk, $next_start, $min_req_total_space, \@worklist);
 
         # msdos does not support partitions larger than 2TB
         ($part->{size}->{eff_size} > (&FAI::convert_unit("2TB") * 1024.0 *
