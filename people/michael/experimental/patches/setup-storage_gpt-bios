2009-04-28  Michael Tautschnig  <mt@debian.org>

  * setup-storage/Parser.pm, setup-storage/Sizes.pm, setup-storage/Volumes.pm:
    Added pseudo-disklabel gpt-bios to support GPT on systems with BIOS instead
    of EFI. Also installs an additional partition to store whatever doesn't fit
    into MBR.
Index: trunk/lib/setup-storage/Commands.pm
===================================================================
--- trunk.orig/lib/setup-storage/Commands.pm
+++ trunk/lib/setup-storage/Commands.pm	
@@ -673,16 +673,17 @@
   # the list of partitions that must be preserved
   my @to_preserve = &FAI::get_preserved_partitions($config);
 
+  my $label = $FAI::configs{$config}{disklabel};
+  $label = "gpt" if ($label eq "gpt-bios");
   # A new disk label may only be written if no partitions need to be
   # preserved
-  (($FAI::configs{$config}{disklabel} eq
-      $FAI::current_config{$disk}{disklabel})
+  (($label eq $FAI::current_config{$disk}{disklabel})
     || (scalar (@to_preserve) == 0)) 
     or die "Can't change disklabel, partitions are to be preserved\n";
 
   # write the disklabel to drop the previous partition table
-  &FAI::push_command( "parted -s $disk mklabel " .
-    $FAI::configs{$config}{disklabel}, "exist_$disk", "cleared1_$disk" );
+  &FAI::push_command( "parted -s $disk mklabel $label", "exist_$disk",
+    "cleared1_$disk" );
 
   &FAI::rebuild_preserved_partitions($config, \@to_preserve);
 
@@ -785,9 +786,8 @@
 
   # write the disklabel again to drop the partition table and create a new one
   # that has the proper ids
-  &FAI::push_command( "parted -s $disk mklabel " .
-    $FAI::configs{$config}{disklabel}, "cleared1_$disk$pre_all_resize",
-    "cleared2_$disk" );
+  &FAI::push_command( "parted -s $disk mklabel $label",
+    "cleared1_$disk$pre_all_resize", "cleared2_$disk" );
 
   my $prev_id = -1;
   # generate the commands for creating all partitions
@@ -837,6 +837,14 @@
       &FAI::make_device_name($disk, $FAI::configs{$config}{bootable}),
       "boot_set_$disk" );
   }
+
+  # set the bios_grub flag on BIOS compatible GPT tables
+  if ($FAI::configs{$config}{disklabel} eq "gpt-bios") {
+    &FAI::push_command( "parted -s $disk set " .
+      $FAI::configs{$config}{gpt_bios_part} . " bios_grub on", "exist_" .
+      &FAI::make_device_name($disk, $FAI::configs{$config}{gpt_bios_part}),
+      "bios_grub_set_$disk" );
+  }
 }
 
 
Index: trunk/lib/setup-storage/Parser.pm
===================================================================
--- trunk.orig/lib/setup-storage/Parser.pm
+++ trunk/lib/setup-storage/Parser.pm	
@@ -431,7 +431,7 @@
           $FAI::configs{$FAI::device}{partitions}{$_}{size}{resize} = 1 foreach (split(",", $1));
           $FAI::configs{$FAI::device}{preserveparts} = 1;
         }
-        | /^disklabel:(msdos|gpt)/
+        | /^disklabel:(msdos|gpt-bios|gpt)/
         {
           # set the disk label - actually not only the above, but all types 
           # supported by parted could be allowed, but others are not implemented
Index: trunk/lib/setup-storage/Sizes.pm
===================================================================
--- trunk.orig/lib/setup-storage/Sizes.pm
+++ trunk/lib/setup-storage/Sizes.pm	
@@ -353,7 +353,8 @@
   }
 
   # on gpt, ensure that the partition ends at a sector boundary
-  if ($FAI::configs{$config}{disklabel} eq "gpt") {
+  if ($FAI::configs{$config}{disklabel} eq "gpt" ||
+    $FAI::configs{$config}{disklabel} eq "gpt-bios") {
     (0 == ($current_disk->{partitions}{$part_id}{end_byte} + 1)
         % $current_disk->{sector_size})
       or die "Preserved partition $part_id does not end at a sector boundary\n";
@@ -548,7 +549,8 @@
   }
 
   # on gpt, ensure that the partition ends at a sector boundary
-  if ($FAI::configs{$config}{disklabel} eq "gpt") {
+  if ($FAI::configs{$config}{disklabel} eq "gpt" ||
+    $FAI::configs{$config}{disklabel} eq "gpt-bios") {
     $end_byte -=
       ($end_byte + 1) % $current_disk->{sector_size};
   }
@@ -621,18 +623,17 @@
     # the start byte for the next partition
     my $next_start = 0;
 
-    # on msdos disk labels, the first partitions starts at head #1
     if ($FAI::configs{$config}{disklabel} eq "msdos") {
+      # on msdos disk labels, the first partitions starts at head #1
       $next_start = $current_disk->{bios_sectors_per_track} *
         $current_disk->{sector_size};
 
       # the MBR requires space, too
       $min_req_total_space += $current_disk->{bios_sectors_per_track} *
         $current_disk->{sector_size};
-    }
 
-    # on GPT disk labels the first 34 and last 34 sectors must be left alone
-    if ($FAI::configs{$config}{disklabel} eq "gpt") {
+    } elsif ($FAI::configs{$config}{disklabel} eq "gpt") {
+      # on GPT-EFI disk labels the first 34 and last 34 sectors must be left alone
       $next_start = 34 * $current_disk->{sector_size};
 
       # modify the disk to claim the space for the second partition table
@@ -640,6 +641,28 @@
 
       # the space required by the GPTs
       $min_req_total_space += 2 * 34 * $current_disk->{sector_size};
+
+    } elsif ($FAI::configs{$config}{disklabel} eq "gpt-bios") {
+      # on BIOS-style disk labels, the first partitions starts at head #1
+      $next_start = $current_disk->{bios_sectors_per_track} *
+        $current_disk->{sector_size};
+
+      # the MBR requires space, too
+      $min_req_total_space += $current_disk->{bios_sectors_per_track} *
+        $current_disk->{sector_size};
+
+      # on gpt-bios we'll need an additional partition to store what doesn't fit
+      # in the MBR
+      $FAI::device = $config;
+      &FAI::init_part_config("primary");
+      $FAI::configs{$config}{gpt_bios_part} = $FAI::partition_pointer->{number};
+      my $s = &FAI::convert_unit("120k");
+      # enter the range into the hash
+      $FAI::partition_pointer->{size}->{range} = "$s-$s";
+      # set proper defaults
+      $FAI::partition_pointer->{encrypt} = 0;
+      $FAI::partition_pointer->{filesystem} = "-";
+      $FAI::partition_pointer->{mountpoint} = "-";
     }
 
     # the list of partitions that we need to find start and end bytes for
@@ -690,7 +713,7 @@
 
         # msdos does not support partitions larger than 2TB
         ($part->{size}->{eff_size} > (&FAI::convert_unit("2TB") * 1024.0 *
-            1024.0)) and die "msdos disklabel does not support partitions > 2TB, please use disklabel:gpt\n"
+            1024.0)) and die "msdos disklabel does not support partitions > 2TB, please use disklabel:gpt or gpt-bios\n"
           if ($FAI::configs{$config}{disklabel} eq "msdos");
         # partition done
         shift @worklist;
Index: trunk/man/setup-storage.8
===================================================================
--- trunk.orig/man/setup-storage.8
+++ trunk/man/setup-storage.8	
@@ -216,7 +216,7 @@
 .br
            /* attempt to resize partitions */
 .br
-           | disklabel:(msdos|gpt)
+           | disklabel:(msdos|gpt|gpt-bios)
 .br
            /* write a disklabel - default is msdos */
 .br
Index: trunk/lib/setup-storage/Volumes.pm
===================================================================
--- trunk.orig/lib/setup-storage/Volumes.pm
+++ trunk/lib/setup-storage/Volumes.pm	
@@ -78,8 +78,9 @@
         "Can't run on test-only mode on this system because there is no disklabel on $disk\n";
 
       # write the disk label as configured
-      $error = &FAI::execute_command("parted -s $disk mklabel "
-        . $FAI::configs{"PHY_$disk"}{disklabel});
+      my $label = $FAI::configs{"PHY_$disk"}{disklabel};
+      $label = "gpt" if ($label eq "gpt-bios");
+      $error = &FAI::execute_command("parted -s $disk mklabel $label");
       ($error eq "") or die "Failed to write disk label\n";
       # retry partition-table print
       $error =
