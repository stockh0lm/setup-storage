2010-10-09  Michael Tautschnig  <mt@debian.org>

	* fai-guide.txt: Improved documentation of hooks (thanks Peter Bittner).
Index: trunk/doc/fai-guide.txt
===================================================================
--- trunk.orig/doc/fai-guide.txt
+++ trunk/doc/fai-guide.txt	
@@ -1895,16 +1895,20 @@
 default tasks as parameters. The example 'partition.DISKLESS' skips
 some default tasks.
 
-The directory '$FAI/hooks/' contains all hooks. The file name of a
-hook consists of a task name as a prefix and a class name, separated
-by a dot. The prefix describes the time when the hook is called, if
-the class is defined for the install client. For example, the hook
-'partition.DISKLESS' is called for every client belonging to the class
-_DISKLESS_ before the local disks would be partitioned. If it should
-become a diskless client, this hook can mount remote file systems via
-NFS and create a _/tmp/fai/fstab_.  After that, the installation
-process will not try to partition and format a local hard disk,
-because a file '/tmp/fai/fstab' already exists.
+The directory '$FAI/hooks/' contains all hooks. A hook is an executable
+file following the naming scheme 'taskname.CLASSNAME[.source]' (e.g.
+'partition.DISKLESS' or 'partition.DISKLESS.source'), a task name and a
+class name separated by a dot, optionally followed by '.source'. The
+task name specifies which task to precede executing this hook, if the
+specified class is defined for the installing client.  See section
+<<tasks>> for a complete list of default tasks that can be used.
+
+In our example, the hook 'partition.DISKLESS' is called for every
+client belonging to the class _DISKLESS_ before the local disks would
+be partitioned. If it should become a diskless client, this hook can
+mount remote file systems via NFS and create a _/tmp/fai/fstab_.  After
+that, the installation process will not try to partition and format a
+local hard disk, because a file '/tmp/fai/fstab' already exists.
 
 A hook of the form _hookprefix.classname_ can't define variables for
 the installation script, because it's a subprocess. But you can use
