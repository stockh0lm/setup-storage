2010-06-28  Michael Tautschnig  <mt@debian.org>

	* setup-storage/Exec.pm: All unexpected non-zero exit codes of subcommands
		lead to immediate failure of setup-storage.
Index: trunk/lib/setup-storage/Exec.pm
===================================================================
--- trunk.orig/lib/setup-storage/Exec.pm
+++ trunk/lib/setup-storage/Exec.pm	
@@ -57,6 +57,7 @@
     stdout_regex => "",
     program      => "parted",
     response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error   => "parted_1_new",
@@ -65,22 +66,25 @@
     stdout_regex => "Error: Could not stat device .* - No such file or directory",
     program      => "parted",
     response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error        => "parted_2",
-    message      => "Parted could not read a disk label\n",
+    message      => "Parted could not read a disk label (new disk?)\n",
     stderr_regex => "Error: Unable to open .* - unrecognised disk label",
     stdout_regex => "",
-    program      => "parted",
+    program      => "parted -s \\S+ unit TiB print",
     response     => "warn",
+    exit_codes   => [1],
   },
   {
     error        => "parted_2_new",
-    message      => "Parted could not read a disk label\n",
+    message      => "Parted could not read a disk label (new disk?)\n",
     stderr_regex => "",
     stdout_regex => "Error: .* unrecognised disk label",
-    program      => "parted",
+    program      => "parted -s \\S+ unit TiB print",
     response     => "warn",
+    exit_codes   => [1],
   },
   ## {
   ##   error        => "parted_3",
@@ -89,6 +93,7 @@
   ##   stdout_regex => "",
   ##   program      => "parted",
   ##   response     => \&FAI::restore_partition_table,
+  ##   exit_codes   => [0..255],
   ## },
   {
     error        => "parted_4",
@@ -97,6 +102,7 @@
     stdout_regex => "",
     program      => "parted",
     response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error        => "parted_4_new",
@@ -105,6 +111,7 @@
     stdout_regex => "No Implementation: Partition \\d+ isn't aligned to cylinder boundaries",
     program      => "parted",
     response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error        => "parted_5",
@@ -113,6 +120,7 @@
     stdout_regex => "",
     program      => "parted",
     response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error        => "parted_5_new",
@@ -121,6 +129,7 @@
     stdout_regex => "Error: Can't have overlapping partitions",
     program      => "parted",
     response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error        => "parted_6",
@@ -129,6 +138,7 @@
     stdout_regex => "",
     program      => "parted",
     response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error        => "parted_6_new",
@@ -137,6 +147,7 @@
     stdout_regex => "Error: Unable to satisfy all constraints on the partition",
     program      => "parted",
     response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error   => "cmd_parted_1",
@@ -144,7 +155,8 @@
     stderr_regex => "(parted: command not found|/sbin/parted: No such file or directory)",
     stdout_regex => "",
     program      => "parted",
-    response     => "die"
+    response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error => "mkfs.xfs_1",
@@ -153,6 +165,7 @@
     stdout_regex => "",
     program      => "mkfs.xfs",
     response     => "die",
+    exit_codes   => [0..255],
   },
   {
     error        => "ntfsresize_1",
@@ -161,6 +174,16 @@
     stdout_regex => "",
     program      => "ntfsresize",
     response     => "die",
+    exit_codes   => [0..255],
+  },
+  {
+    error        => "catch_all_nonzero_exit_code",
+    message      => "Command had non-zero exit code\n",
+    stderr_regex => "",
+    stdout_regex => "",
+    program      => ".*",
+    response     => "die",
+    exit_codes   => [1..255],
   },
 ];
 
@@ -300,6 +323,7 @@
   my @stdout      = ();
   my $stderr_line = "";
   my $stdout_line = "";
+  my $exit_code   = 0;
 
   #make tempfile, get perl filehandle and filename of the file
   my ($stderr_fh, $stderr_filename) = File::Temp::tempfile(UNLINK => 1);
@@ -314,9 +338,10 @@
     # execute the bash command, write stderr and stdout into the testfiles
     print "Executing: $command\n";
     `$command 1> $stdout_filename 2> $stderr_filename`;
-    ( ($?>>8) ne 0 ) and warn "Command $command had exit code " . ($?>>8) . "\n";
+    $exit_code = ($?>>8);
   } else {
-    print "would run command $command; to have them executed, use -X \n";
+    print "would run command $command; to have it executed, use -X \n";
+    return "";
   }
 
   # read the tempfile into lists, each element of the list one line
@@ -344,11 +369,11 @@
 
   #get the error, if there was any
   foreach my $err (@$FAI::error_codes) {
-    if (($err->{stdout_regex} eq "" || $stdout_line =~ /$err->{stdout_regex}/)
-      && ($err->{stderr_regex} eq "" || $stderr_line =~ /$err->{stderr_regex}/)
-      && ($err->{program} eq "" || $command =~ /$err->{program}/)) {
-      return $err->{error};
-    }
+    return $err->{error} if
+      (($err->{stdout_regex} eq "" || $stdout_line =~ /$err->{stdout_regex}/)
+        && ($err->{stderr_regex} eq "" || $stderr_line =~ /$err->{stderr_regex}/)
+        && ($err->{program} eq "" || $command =~ /$err->{program}/)
+        && (grep {$_ == $exit_code} @{ $err->{exit_codes} }));
   }
 
 }
