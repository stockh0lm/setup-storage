2011-03-10  Michael Tautschnig  <mt@debian.org>

	* setup-storage/{Parser,Sizes,Fstab,Volumes}.pm: Don't keep redundant number
		field in config data structure.
	* setup-storage/Sizes.pm: Removed redundant min_req_total_space tracking
		variable.
Index: trunk/lib/setup-storage/Fstab.pm
===================================================================
--- trunk.orig/lib/setup-storage/Fstab.pm
+++ trunk/lib/setup-storage/Fstab.pm
@@ -224,8 +224,8 @@
         # skip extended partitions and entries without a mountpoint
         next if ($p_ref->{size}->{extended} || $p_ref->{mountpoint} eq "-");
 
-        my $device_name = 0 == $p_ref->{number} ? $device :
-          &FAI::make_device_name($device, $p_ref->{number});
+        my $device_name = 0 == $p ? $device :
+          &FAI::make_device_name($device, $p);
 
         # if the mount point the /boot mount point, variables must be set
         if ($p_ref->{mountpoint} eq $boot_mnt_point) {
Index: trunk/lib/setup-storage/Parser.pm
===================================================================
--- trunk.orig/lib/setup-storage/Parser.pm
+++ trunk/lib/setup-storage/Parser.pm
@@ -275,10 +275,6 @@
           size => {}
         };
 
-      # as we can't compute the index from the reference, we need to store the
-      # $part_number explicitly
-      (\%FAI::configs)->{$FAI::device}->{partitions}->{$extended}->{number} = $extended;
-
       my $part_size =
         (\%FAI::configs)->{$FAI::device}->{partitions}->{$extended}->{size};
 
@@ -313,10 +309,6 @@
     (\%FAI::configs)->{$FAI::device}->{partitions}->{$part_number};
   $FAI::partition_pointer_dev_name = &FAI::make_device_name($disk, $part_number);
 
-  # as we can't compute the index from the reference, we need to store the
-  # $part_number explicitly
-  $FAI::partition_pointer->{number} = $part_number;
-
   # the partition is not an extended one
   $FAI::partition_pointer->{size}->{extended} = 0;
 
Index: trunk/lib/setup-storage/Sizes.pm
===================================================================
--- trunk.orig/lib/setup-storage/Sizes.pm
+++ trunk/lib/setup-storage/Sizes.pm
@@ -295,15 +295,14 @@
 # @param $config Disk config
 # @param $current_disk Current config of this disk
 # @param $next_start Start of the next partition
-# @param $min_req_total_space Minimum space required on disk
 # @param $max_avail The maximum size of a partition on this disk
 #
-# @return Updated values of ($next_start, $min_req_total_space)
+# @return Updated value of $next_start
 #
 ################################################################################
 sub do_partition_preserve {
 
-  my ($part_id, $config, $disk, $next_start, $min_req_total_space, $max_avail) = @_;
+  my ($part_id, $config, $disk, $next_start, $max_avail) = @_;
   # reference to the current disk config
   my $current_disk = $FAI::current_config{$disk};
 
@@ -335,9 +334,6 @@
   $part->{start_byte} = $curr_part->{begin_byte};
   $part->{end_byte} = $curr_part->{end_byte};
 
-  # and add it to the total disk space required by this config
-  $min_req_total_space += $part->{size}->{eff_size};
-
   # set the next start
   $next_start = $part->{end_byte} + 1;
 
@@ -354,9 +350,6 @@
           $current_disk->{bios_heads})) or 
       warn "Preserved partition $part_dev_name does not end at a cylinder boundary, parted may fail to restore the partition!\n";
 
-    # add two sectors of disk usage if this is a logical partition
-    $min_req_total_space += 2 * $current_disk->{sector_size} if ($part_id > 4);
-
     # make sure we don't change extended partitions to ordinary ones and
     # vice-versa
     ($part->{size}->{extended} == $curr_part->{is_extended})
@@ -375,7 +368,7 @@
       or die "Preserved partition $part_dev_name does not end at a sector boundary\n";
   }
 
-  return ($next_start, $min_req_total_space);
+  return $next_start;
 }
 
 ################################################################################
@@ -431,17 +424,15 @@
 # @param $disk This disk
 # @param $next_start Start of the next partition
 # @param $block_size Requested alignment
-# @param $min_req_total_space Minimum space required on disk
 # @param $max_avail The maximum size of a partition on this disk
 # @param $worklist Reference to the remaining partitions
 #
-# @return Updated values of ($next_start, $min_req_total_space)
+# @return Updated value of $next_start
 #
 ################################################################################
 sub do_partition_real {
 
-  my ($part_id, $config, $disk, $next_start, $block_size, $min_req_total_space,
-    $max_avail, $worklist) = @_;
+  my ($part_id, $config, $disk, $next_start, $block_size, $max_avail, $worklist) = @_;
   # reference to the current disk config
   my $current_disk = $FAI::current_config{$disk};
 
@@ -452,15 +443,8 @@
 
   # compute the effective start location on the disk
   # msdos specific offset for logical partitions
-  if (($FAI::configs{$config}{disklabel} eq "msdos")
-    && ($part_id > 4)) {
-
-    # add 2 sectors of disk usage if this is a logical partition
-    $min_req_total_space += 2 * $current_disk->{sector_size};
-
-    # move the start byte as well
-    $next_start += 2 * $current_disk->{sector_size};
-  }
+  $next_start += 2 * $current_disk->{sector_size}
+    if (($FAI::configs{$config}{disklabel} eq "msdos") && ($part_id > 4));
 
   # partition starts at where we currently are + requested alignment, or remains
   # fixed in case of resized ntfs
@@ -568,13 +552,10 @@
   # write the end byte to the configuration
   $part->{end_byte} = $end_byte;
 
-  # and add it to the total disk space required by this config
-  $min_req_total_space += $part->{size}->{eff_size};
-
   # set the next start
   $next_start = $part->{end_byte} + 1;
 
-  return ($next_start, $min_req_total_space);
+  return $next_start;
 }
 
 ################################################################################
@@ -634,9 +615,6 @@
       }
     }
 
-    # the space required on the disk
-    my $min_req_total_space = 0;
-
     # the start byte for the next partition
     my $next_start = 0;
 
@@ -644,7 +622,6 @@
       # on msdos disk labels, the first partitions starts at head #1; well,
       # enforce a 63-sectors-per-track layout
       $next_start = 63 * $current_disk->{sector_size};
-      $min_req_total_space += $next_start;
 
     } elsif ($FAI::configs{$config}{disklabel} eq "gpt") {
       # on GPT-EFI disk labels the first 34 and last 33 sectors must be left alone
@@ -653,31 +630,24 @@
       # modify the disk to claim the space for the second partition table
       $current_disk->{end_byte} -= 33 * $current_disk->{sector_size};
 
-      # the space required by the GPTs
-      $min_req_total_space += (34 + 33) * $current_disk->{sector_size};
-
     } elsif ($FAI::configs{$config}{disklabel} eq "gpt-bios") {
       # the MBR requires space, too
       $next_start = $current_disk->{sector_size};
-      $min_req_total_space += $current_disk->{sector_size};
       # not too sure whether this is needed: standard GPT partition table space
       $next_start += 33 * $current_disk->{sector_size};
-      $min_req_total_space += 33 * $current_disk->{sector_size};
 
       # apparently parted insists in having some space left at the end too
       # modify the disk to claim the space for the second partition table
       $current_disk->{end_byte} -= 33 * $current_disk->{sector_size};
 
-      # the space required by the GPTs
-      $min_req_total_space += 33 * $current_disk->{sector_size};
-
       # on gpt-bios we'll need an additional partition to store what doesn't fit
       # in the MBR; this partition must be at the beginning, but it should be
       # created at the very end such as not to invalidate indices of other
       # partitions
       $FAI::device = $config;
       &FAI::init_part_config("primary");
-      $FAI::configs{$config}{gpt_bios_part} = $FAI::partition_pointer->{number};
+      $FAI::configs{$config}{gpt_bios_part} =
+        (&FAI::phys_dev($FAI::partition_pointer_dev_name))[2];
       my ($s, $e) = &FAI::make_range("1-1", $current_disk->{size} . "B");
       # enter the range into the hash
       $FAI::partition_pointer->{size}->{range} = "$s-$s";
@@ -685,7 +655,6 @@
       $FAI::partition_pointer->{start_byte} = $next_start;
       $FAI::partition_pointer->{end_byte} = $next_start + $s - 1;
       $next_start += $s;
-      $min_req_total_space += $s;
       # set proper defaults
       $FAI::partition_pointer->{encrypt} = 0;
       $FAI::partition_pointer->{filesystem} = "-";
@@ -693,7 +662,7 @@
     }
 
     # the size of a 100% partition (the 100% available to the user)
-    my $max_avail = $current_disk->{size} - $min_req_total_space;
+    my $max_avail = $current_disk->{size} - $next_start;
     # expressed in bytes
     $max_avail = "${max_avail}B";
 
@@ -747,15 +716,14 @@
         shift @worklist;
       # the partition $part_id must be preserved
       } elsif ($part->{size}->{preserve}) {
-        ($next_start, $min_req_total_space) = &FAI::do_partition_preserve($part_id,
-          $config, $disk, $next_start, $min_req_total_space, $max_avail);
+        $next_start = &FAI::do_partition_preserve($part_id, $config, $disk,
+          $next_start, $max_avail);
 
         # partition done
         shift @worklist;
       } else {
-        ($next_start, $min_req_total_space) = &FAI::do_partition_real($part_id, 
-          $config, $disk, $next_start, $block_size, $min_req_total_space,
-          $max_avail, \@worklist);
+        $next_start = &FAI::do_partition_real($part_id, $config, $disk,
+          $next_start, $block_size, $max_avail, \@worklist);
 
         # msdos does not support partitions larger than 2TiB
         ($part->{size}->{eff_size} > (&FAI::convert_unit("2TiB") * 1024.0 *
@@ -767,8 +735,8 @@
     }
 
     # check, whether there is sufficient space on the disk
-    ($min_req_total_space > $current_disk->{size})
-      and die "Disk $disk is too small - at least $min_req_total_space bytes are required\n";
+    ($next_start > $current_disk->{end_byte} + 1)
+      and die "Disk $disk is too small - at least $next_start bytes are required\n";
 
     # make sure, extended partitions are only created on msdos disklabels
     ($FAI::configs{$config}{disklabel} ne "msdos" && $extended > -1)
Index: trunk/lib/setup-storage/Volumes.pm
===================================================================
--- trunk.orig/lib/setup-storage/Volumes.pm
+++ trunk/lib/setup-storage/Volumes.pm
@@ -578,10 +578,10 @@
           defined ($FAI::current_config{$1}) or die
             "Can't preserve partition on $1 because $1 does not exist\n";
           defined ($FAI::current_config{$1}{partitions}{$part_id}) or die
-            "Can't preserve ". &FAI::make_device_name($1, $part->{number})
+            "Can't preserve ". &FAI::make_device_name($1, $part_id)
               . " because it does not exist\n";
           defined ($part->{size}->{range}) or die
-            "Can't preserve ". &FAI::make_device_name($1, $part->{number})
+            "Can't preserve ". &FAI::make_device_name($1, $part_id)
               . " because it is not defined in the current config\n";
         }
       }
