2011-02-11  Julien Blache  <jblache@debian.org>
	
	* setup-storage/Sizes.pm: for backward compatibility with previous
		setup-storage versions, msdos partitions must be aligned to cylinder
		boundary and alignment constraints must not apply for start position of
		partitions 1 and 5. Preserving partitions on systems installed with previous
		versions of setup-storage breaks without this.

2010-09-18  Michael Tautschnig  <mt@debian.org>

	* setup-storage/{Parser.pm,Sizes.pm}: Align partition sizes to sectors or
		user-requested alignment on all disk labels, dropping DOS
		cylinder-alignment. Thanks Patrick Cervicek for suggesting the
		user-specified alignment.
	* setup-storage.8: Document new align-at option.
	* setup-storage/Sizes.pm: Take alignment into account for partition size
		computation (thanks Frank Doepper for bringing up this problem). Size of
		extended (partition) boot record is 2 sectors.
Index: trunk/lib/setup-storage/Sizes.pm
===================================================================
--- trunk.orig/lib/setup-storage/Sizes.pm
+++ trunk/lib/setup-storage/Sizes.pm
@@ -353,9 +353,8 @@
           $current_disk->{bios_heads})) or 
       warn "Preserved partition $part_dev_name does not end at a cylinder boundary, parted may fail to restore the partition!\n";
 
-    # add one head of disk usage if this is a logical partition
-    $min_req_total_space += $current_disk->{bios_sectors_per_track} *
-      $current_disk->{sector_size} if ($part_id > 4);
+    # add two sectors of disk usage if this is a logical partition
+    $min_req_total_space += 2 * $current_disk->{sector_size} if ($part_id > 4);
 
     # make sure we don't change extended partitions to ordinary ones and
     # vice-versa
@@ -401,9 +400,6 @@
   ($part_id <= 4) or
     &FAI::internal_error("Extended partition wouldn't be a primary one");
 
-  my $epbr_size = $current_disk->{bios_sectors_per_track} *
-    $current_disk->{sector_size};
-
   # initialise the size and the start byte
   $part->{size}->{eff_size} = 0;
   $part->{start_byte} = -1;
@@ -412,10 +408,11 @@
     next if ($p < 5);
 
     $part->{start_byte} = $FAI::configs{$config}{partitions}{$p}{start_byte} -
-      $epbr_size if (-1 == $part->{start_byte});
+      (2 * $current_disk->{sector_size}) if (-1 == $part->{start_byte});
 
-    $part->{size}->{eff_size} += $FAI::configs{$config}{partitions}{$p}{size}{eff_size} +
-      $epbr_size;
+    $part->{size}->{eff_size} +=
+      $FAI::configs{$config}{partitions}{$p}{size}{eff_size} + (2 *
+        $current_disk->{sector_size});
 
     $part->{end_byte} = $FAI::configs{$config}{partitions}{$p}{end_byte};
   }
@@ -430,8 +427,9 @@
 #
 # @param $part_id Partition id within $config
 # @param $config Disk config
-# @param $current_disk Current config of this disk
+# @param $disk This disk
 # @param $next_start Start of the next partition
+# @param $block_size Requested alignment
 # @param $min_req_total_space Minimum space required on disk
 # @param $worklist Reference to the remaining partitions
 #
@@ -440,7 +438,7 @@
 ################################################################################
 sub do_partition_real {
 
-  my ($part_id, $config, $disk, $next_start, $min_req_total_space, $worklist) = @_;
+  my ($part_id, $config, $disk, $next_start, $block_size, $min_req_total_space, $worklist) = @_;
   # reference to the current disk config
   my $current_disk = $FAI::current_config{$disk};
 
@@ -450,6 +448,34 @@
   my ($start, $end) = &FAI::make_range($part->{size}->{range},
     $current_disk->{size} . "B");
 
+  # compute the effective start location on the disk
+  # msdos specific offset for logical partitions
+  if (($FAI::configs{$config}{disklabel} eq "msdos")
+    && ($part_id > 4)) {
+
+    # add 2 sectors of disk usage if this is a logical partition
+    $min_req_total_space += 2 * $current_disk->{sector_size};
+
+    # move the start byte as well
+    $next_start += 2 * $current_disk->{sector_size};
+  }
+
+  # partition starts at where we currently are + requested alignment, or remains
+  # fixed in case of resized ntfs
+  # Also, don't apply alignment constraint to partition 1 and 5 in an msdos disklabel
+  if ($FAI::configs{$config}{partitions}{$part_id}{size}{resize} &&
+    ($current_disk->{partitions}->{$part_id}->{filesystem} eq "ntfs")) {
+    ($next_start <= $current_disk->{partitions}->{$part_id}->{begin_byte})
+      or die "Cannot preserve start byte of ntfs volume on partition $part_id, space before it is too small\n";
+    $next_start = $current_disk->{partitions}->{$part_id}->{begin_byte};
+  } elsif ((0 != $next_start % $block_size)
+	   && ((($part_id != 5) && ($part_id != 1))
+	       || ($FAI::configs{$config}{disklabel} ne "msdos"))) {
+    $next_start += $block_size - ($next_start % $block_size);
+  }
+  $FAI::configs{$config}{partitions}{$part_id}{start_byte} =
+    $next_start;
+
   # check, whether the size is fixed
   if ($end != $start) {
 
@@ -477,11 +503,8 @@
 
         # logical partitions require the space for the EPBR to be left
         # out
-        if (($FAI::configs{$config}{disklabel} eq "msdos")
-          && ($p > 4)) {
-          $end_of_range -= $current_disk->{bios_sectors_per_track} *
-            $current_disk->{sector_size};
-        }
+        $end_of_range -= 2 * $current_disk->{sector_size} 
+          if (($FAI::configs{$config}{disklabel} eq "msdos") && ($p > 4));
         last;
       } elsif ($FAI::configs{$config}{partitions}{$p}{size}{extended}) {
         next;
@@ -491,13 +514,11 @@
           $current_disk->{size} . "B");
 
         # logical partitions require the space for the EPBR to be left
-        # out
+        # out; in fact, even alignment constraints would have to be considered
         if (($FAI::configs{$config}{disklabel} eq "msdos")
-          && ($p > 4)) {
-          $min_size += $current_disk->{bios_sectors_per_track} *
-            $current_disk->{sector_size};
-          $max_size += $current_disk->{bios_sectors_per_track} *
-            $current_disk->{sector_size};
+          && ($p != $part_id) && ($p > 4)) {
+          $min_size += 2 * $current_disk->{sector_size};
+          $max_size += 2 * $current_disk->{sector_size};
         }
 
         $min_req_space += $min_size;
@@ -529,48 +550,9 @@
     $end   = $start;
   }
 
-  # now we compute the effective locations on the disk
-  # msdos specific offset for logical partitions
-  if (($FAI::configs{$config}{disklabel} eq "msdos")
-    && ($part_id > 4)) {
-
-    # add one head of disk usage if this is a logical partition
-    $min_req_total_space += $current_disk->{bios_sectors_per_track} *
-      $current_disk->{sector_size};
-
-    # move the start byte as well
-    $next_start += $current_disk->{bios_sectors_per_track} *
-      $current_disk->{sector_size};
-  }
-
-  # partition starts at where we currently are, or remains fixed in case of
-  # resized ntfs
-  if ($FAI::configs{$config}{partitions}{$part_id}{size}{resize} &&
-    ($current_disk->{partitions}->{$part_id}->{filesystem} eq "ntfs")) {
-    ($next_start <= $current_disk->{partitions}->{$part_id}->{begin_byte}) 
-      or die "Cannot preserve start byte of ntfs volume on partition $part_id, space before it is too small\n";
-    $next_start = $current_disk->{partitions}->{$part_id}->{begin_byte};
-  }
-  $FAI::configs{$config}{partitions}{$part_id}{start_byte} =
-    $next_start;
-
-  # the end may need some alignment, depending on the disk label
+  # partitions must end at the requested alignment
   my $end_byte = $next_start + $start - 1;
-
-  # on msdos, ensure that the partition ends at a cylinder boundary
-  if ($FAI::configs{$config}{disklabel} eq "msdos") {
-    $end_byte -=
-      ($end_byte + 1) % ($current_disk->{sector_size} *
-        $current_disk->{bios_sectors_per_track} *
-        $current_disk->{bios_heads});
-  }
-
-  # on gpt, ensure that the partition ends at a sector boundary
-  if ($FAI::configs{$config}{disklabel} eq "gpt" ||
-    $FAI::configs{$config}{disklabel} eq "gpt-bios") {
-    $end_byte -=
-      ($end_byte + 1) % $current_disk->{sector_size};
-  }
+  $end_byte -= ($end_byte + 1) % $block_size;
 
   # set $start and $end to the effective values
   $start = $end_byte - $next_start + 1;
@@ -619,6 +601,21 @@
     # reference to the current disk config
     my $current_disk = $FAI::current_config{$disk};
 
+    # align to sector boundary by default
+    my $block_size = $current_disk->{sector_size};
+    # align to cylinder boundary for msdos disklabels, for backward compatibility
+    if ($FAI::configs{$config}{disklabel} eq "msdos") {
+      $block_size = $current_disk->{sector_size} *
+        $current_disk->{bios_sectors_per_track} *
+        $current_disk->{bios_heads};
+    }
+    # but user-specified alignment wins no matter what
+    defined ($FAI::configs{$config}{align_at}) and
+      $block_size = $FAI::configs{$config}{align_at};
+
+    (0 == $block_size % $current_disk->{sector_size}) or
+      die "Alignment must be set to a multiple of the underlying disk sector size\n";
+
     # at various points the following code highly depends on the desired disk label!
     # initialise variables
     # the id of the extended partition to be created, if required
@@ -662,13 +659,12 @@
       $min_req_total_space += (34 + 33) * $current_disk->{sector_size};
 
     } elsif ($FAI::configs{$config}{disklabel} eq "gpt-bios") {
-      # on BIOS-style disk labels, the first partitions starts at head #1
-      $next_start = $current_disk->{bios_sectors_per_track} *
-        $current_disk->{sector_size};
-
       # the MBR requires space, too
-      $min_req_total_space += $current_disk->{bios_sectors_per_track} *
-        $current_disk->{sector_size};
+      $next_start = $current_disk->{sector_size};
+      $min_req_total_space += $current_disk->{sector_size};
+      # not too sure whether this is needed: standard GPT partition table space
+      $next_start += 33 * $current_disk->{sector_size};
+      $min_req_total_space += 33 * $current_disk->{sector_size};
 
       # apparently parted insists in having some space left at the end too
       # modify the disk to claim the space for the second partition table
@@ -755,7 +751,7 @@
         shift @worklist;
       } else {
         ($next_start, $min_req_total_space) = &FAI::do_partition_real($part_id, 
-          $config, $disk, $next_start, $min_req_total_space, \@worklist);
+          $config, $disk, $next_start, $block_size, $min_req_total_space, \@worklist);
 
         # msdos does not support partitions larger than 2TiB
         ($part->{size}->{eff_size} > (&FAI::convert_unit("2TiB") * 1024.0 *
Index: trunk/lib/setup-storage/Parser.pm
===================================================================
--- trunk.orig/lib/setup-storage/Parser.pm
+++ trunk/lib/setup-storage/Parser.pm
@@ -630,6 +630,10 @@
         {
           $FAI::configs{$FAI::device}{partitions}{$_}{size}{always_format} = 1 foreach (split(",", $1));
         }
+        | /^align-at:(\d+[kKMGTPiB]*)/
+        {
+          $FAI::configs{$FAI::device}{align_at} = &FAI::convert_unit($1) * 1024.0 * 1024.0;
+        }
 
     volume: /^vg\s+/ name devices vgcreateopt(s?)
         | /^raid([0156]|10)\s+/
@@ -791,7 +795,7 @@
           1;
         }
 
-    size: /^((RAM:\d+%|\d+[kMGTP%iB]*)(-(RAM:\d+%|\d+[kMGTP%iB]*)?)?)(:resize)?/
+    size: /^((RAM:\d+%|\d+[kKMGTP%iB]*)(-(RAM:\d+%|\d+[kKMGTP%iB]*)?)?)(:resize)?/
         {
           # complete the size specification to be a range in all cases
           my $range = $1;
@@ -822,7 +826,7 @@
             $FAI::configs{$FAI::device}{preserveparts} = 1;
           }
         }
-        | /^(-(RAM:\d+%|\d+[kMGTP%iB]*))(:resize)?\s+/
+        | /^(-(RAM:\d+%|\d+[kKMGTP%iB]*))(:resize)?\s+/
         {
           # complete the range by assuming 0 as the lower limit 
           my $range = "0$1";
@@ -843,7 +847,7 @@
         }
         | <error: invalid partition size near "$text">
 
-    tmpfs_size: /^(RAM:(\d+%)|\d+[kMGTPiB]*)\s+/
+    tmpfs_size: /^(RAM:(\d+%)|\d+[kKMGTPiB]*)\s+/
         {
           my $size;
 
Index: trunk/man/setup-storage.8
===================================================================
--- trunk.orig/man/setup-storage.8
+++ trunk/man/setup-storage.8
@@ -284,6 +284,20 @@
 .br
            */
 .br
+           | align-at:([[:digit:]]+[kKMGTPiB]*)
+.br
+           /* Align partitions at multiples of the given block size (unit
+.br
+           defaults to MiB, if omitted). Such an alignment, e.g., 4K, might be
+.br
+           important for proper performance of RAID arrays which use a logical
+.br
+           block size other than the sector size of the underlying disks. It
+.br
+           must, however, always be a multiple of this sector size.
+.br
+           */
+.br
 
 
 volume ::= <type> <mountpoint> <size> <filesystem> <mount_options> <fs_options>
